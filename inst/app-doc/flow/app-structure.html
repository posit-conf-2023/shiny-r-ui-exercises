<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>nomnoml</title>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      cel.style.position = "absolute";
      var pad = unpackPadding(sizing.padding);
      cel.style.top = pad.top + "px";
      cel.style.right = pad.right + "px";
      cel.style.bottom = pad.bottom + "px";
      cel.style.left = pad.left + "px";
      el.style.width = "100%";
      el.style.height = "100%";

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var rect = el.getBoundingClientRect();
            var result = bindingDef.initialize(el, rect.width, rect.height);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        var getSize = function(el) {
          if (sizeObj) {
            return {w: sizeObj.getWidth(), h: sizeObj.getHeight()}
          } else {
            var rect = el.getBoundingClientRect();
            return {w: rect.width, h: rect.height}
          }
        };

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          var size = getSize(el);
          initResult = binding.initialize(el, size.w, size.h);
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = getSize(el);
          var resizeHandler = function(e) {
            var size = getSize(el);
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();
</script>
<script>/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/returnExports.js
(function (root, factory) {
  /*global define */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.returnExports = factory();
  }
}(this, function () {
  'use strict';

  var _apply = Function.call.bind(Function.apply);
  var _call = Function.call.bind(Function.call);
  var isArray = Array.isArray;
  var keys = Object.keys;

  var not = function notThunker(func) {
    return function notThunk() {
      return !_apply(func, this, arguments);
    };
  };
  var throwsError = function (func) {
    try {
      func();
      return false;
    } catch (e) {
      return true;
    }
  };
  var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {
    try {
      return func();
    } catch (e) {
      return false;
    }
  };

  var isCallableWithoutNew = not(throwsError);
  var arePropertyDescriptorsSupported = function () {
    // if Object.defineProperty exists but throws, it's IE 8
    return !throwsError(function () {
      return Object.defineProperty({}, 'x', { get: function () { } }); // eslint-disable-line getter-return
    });
  };
  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
  var functionsHaveNames = (function foo() {}).name === 'foo'; // eslint-disable-line no-extra-parens

  var _forEach = Function.call.bind(Array.prototype.forEach);
  var _reduce = Function.call.bind(Array.prototype.reduce);
  var _filter = Function.call.bind(Array.prototype.filter);
  var _some = Function.call.bind(Array.prototype.some);

  var defineProperty = function (object, name, value, force) {
    if (!force && name in object) { return; }
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };

  // Define configurable, writable and non-enumerable props
  // if they donâ€™t exist.
  var defineProperties = function (object, map, forceOverride) {
    _forEach(keys(map), function (name) {
      var method = map[name];
      defineProperty(object, name, method, !!forceOverride);
    });
  };

  var _toString = Function.call.bind(Object.prototype.toString);
  var isCallable = typeof /abc/ === 'function' ? function IsCallableSlow(x) {
    // Some old browsers (IE, FF) say that typeof /abc/ === 'function'
    return typeof x === 'function' && _toString(x) === '[object Function]';
  } : function IsCallableFast(x) { return typeof x === 'function'; };

  var Value = {
    getter: function (object, name, getter) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        get: getter
      });
    },
    proxy: function (originalObject, key, targetObject) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
      Object.defineProperty(targetObject, key, {
        configurable: originalDescriptor.configurable,
        enumerable: originalDescriptor.enumerable,
        get: function getKey() { return originalObject[key]; },
        set: function setKey(value) { originalObject[key] = value; }
      });
    },
    redefine: function (object, property, newValue) {
      if (supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(object, property);
        descriptor.value = newValue;
        Object.defineProperty(object, property, descriptor);
      } else {
        object[property] = newValue;
      }
    },
    defineByDescriptor: function (object, property, descriptor) {
      if (supportsDescriptors) {
        Object.defineProperty(object, property, descriptor);
      } else if ('value' in descriptor) {
        object[property] = descriptor.value;
      }
    },
    preserveToString: function (target, source) {
      if (source && isCallable(source.toString)) {
        defineProperty(target, 'toString', source.toString.bind(source), true);
      }
    }
  };

  // Simple shim for Object.create on ES3 browsers
  // (unlike real shim, no attempt to support `prototype === null`)
  var create = Object.create || function (prototype, properties) {
    var Prototype = function Prototype() {};
    Prototype.prototype = prototype;
    var object = new Prototype();
    if (typeof properties !== 'undefined') {
      keys(properties).forEach(function (key) {
        Value.defineByDescriptor(object, key, properties[key]);
      });
    }
    return object;
  };

  var supportsSubclassing = function (C, f) {
    if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }
    return valueOrFalseIfThrows(function () {
      var Sub = function Subclass(arg) {
        var o = new C(arg);
        Object.setPrototypeOf(o, Subclass.prototype);
        return o;
      };
      Object.setPrototypeOf(Sub, C);
      Sub.prototype = create(C.prototype, {
        constructor: { value: Sub }
      });
      return f(Sub);
    });
  };

  var getGlobal = function () {
    /* global self, window */
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') { return self; }
    if (typeof window !== 'undefined') { return window; }
    if (typeof global !== 'undefined') { return global; }
    throw new Error('unable to locate global object');
  };

  var globals = getGlobal();
  var globalIsFinite = globals.isFinite;
  var _indexOf = Function.call.bind(String.prototype.indexOf);
  var _arrayIndexOfApply = Function.apply.bind(Array.prototype.indexOf);
  var _concat = Function.call.bind(Array.prototype.concat);
  // var _sort = Function.call.bind(Array.prototype.sort);
  var _strSlice = Function.call.bind(String.prototype.slice);
  var _push = Function.call.bind(Array.prototype.push);
  var _pushApply = Function.apply.bind(Array.prototype.push);
  var _join = Function.call.bind(Array.prototype.join);
  var _shift = Function.call.bind(Array.prototype.shift);
  var _max = Math.max;
  var _min = Math.min;
  var _floor = Math.floor;
  var _abs = Math.abs;
  var _exp = Math.exp;
  var _log = Math.log;
  var _sqrt = Math.sqrt;
  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
  var ArrayIterator; // make our implementation private
  var noop = function () {};

  var OrigMap = globals.Map;
  var origMapDelete = OrigMap && OrigMap.prototype['delete'];
  var origMapGet = OrigMap && OrigMap.prototype.get;
  var origMapHas = OrigMap && OrigMap.prototype.has;
  var origMapSet = OrigMap && OrigMap.prototype.set;

  var Symbol = globals.Symbol || {};
  var symbolSpecies = Symbol.species || '@@species';

  var numberIsNaN = Number.isNaN || function isNaN(value) {
    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN('foo') => true
    return value !== value;
  };
  var numberIsFinite = Number.isFinite || function isFinite(value) {
    return typeof value === 'number' && globalIsFinite(value);
  };
  var _sign = isCallable(Math.sign) ? Math.sign : function sign(value) {
    var number = Number(value);
    if (number === 0) { return number; }
    if (numberIsNaN(number)) { return number; }
    return number < 0 ? -1 : 1;
  };
  var _log1p = function log1p(value) {
    var x = Number(value);
    if (x < -1 || numberIsNaN(x)) { return NaN; }
    if (x === 0 || x === Infinity) { return x; }
    if (x === -1) { return -Infinity; }

    return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));
  };

  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
  // can be replaced with require('is-arguments') if we ever use a build process instead
  var isStandardArguments = function isArguments(value) {
    return _toString(value) === '[object Arguments]';
  };
  var isLegacyArguments = function isArguments(value) {
    return value !== null &&
      typeof value === 'object' &&
      typeof value.length === 'number' &&
      value.length >= 0 &&
      _toString(value) !== '[object Array]' &&
      _toString(value.callee) === '[object Function]';
  };
  var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

  var Type = {
    primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },
    string: function (x) { return _toString(x) === '[object String]'; },
    regex: function (x) { return _toString(x) === '[object RegExp]'; },
    symbol: function (x) {
      return typeof globals.Symbol === 'function' && typeof x === 'symbol';
    }
  };

  var overrideNative = function overrideNative(object, property, replacement) {
    var original = object[property];
    defineProperty(object, property, replacement, true);
    Value.preserveToString(object[property], original);
  };

  // eslint-disable-next-line no-restricted-properties
  var hasSymbols = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' && Type.symbol(Symbol());

  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
  // we're going to use an arbitrary _-prefixed name to make our shims
  // work properly with each other, even though we don't have full Iterator
  // support.  That is, `Array.from(map.keys())` will work, but we don't
  // pretend to export a "real" Iterator interface.
  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
  // Firefox ships a partial implementation using the name @@iterator.
  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
  // So use that name if we detect it.
  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }

  // Reflect
  if (!globals.Reflect) {
    defineProperty(globals, 'Reflect', {}, true);
  }
  var Reflect = globals.Reflect;

  var $String = String;

  /* global document */
  var domAll = (typeof document === 'undefined' || !document) ? null : document.all;
  var isNullOrUndefined = domAll == null ? function isNullOrUndefined(x) {
    return x == null;
  } : function isNullOrUndefinedAndNotDocumentAll(x) {
    return x == null && x !== domAll;
  };

  var ES = {
    // http://www.ecma-international.org/ecma-262/6.0/#sec-call
    Call: function Call(F, V) {
      var args = arguments.length > 2 ? arguments[2] : [];
      if (!ES.IsCallable(F)) {
        throw new TypeError(F + ' is not a function');
      }
      return _apply(F, V, args);
    },

    RequireObjectCoercible: function (x, optMessage) {
      if (isNullOrUndefined(x)) {
        throw new TypeError(optMessage || 'Cannot call method on ' + x);
      }
      return x;
    },

    // This might miss the "(non-standard exotic and does not implement
    // [[Call]])" case from
    // http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation
    // but we can't find any evidence these objects exist in practice.
    // If we find some in the future, you could test `Object(x) === x`,
    // which is reliable according to
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toobject
    // but is not well optimized by runtimes and creates an object
    // whenever it returns false, and thus is very slow.
    TypeIsObject: function (x) {
      if (x === void 0 || x === null || x === true || x === false) {
        return false;
      }
      return typeof x === 'function' || typeof x === 'object' || x === domAll;
    },

    ToObject: function (o, optMessage) {
      return Object(ES.RequireObjectCoercible(o, optMessage));
    },

    IsCallable: isCallable,

    IsConstructor: function (x) {
      // We can't tell callables from constructors in ES5
      return ES.IsCallable(x);
    },

    ToInt32: function (x) {
      return ES.ToNumber(x) >> 0;
    },

    ToUint32: function (x) {
      return ES.ToNumber(x) >>> 0;
    },

    ToNumber: function (value) {
      if (hasSymbols && _toString(value) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return +value;
    },

    ToInteger: function (value) {
      var number = ES.ToNumber(value);
      if (numberIsNaN(number)) { return 0; }
      if (number === 0 || !numberIsFinite(number)) { return number; }
      return (number > 0 ? 1 : -1) * _floor(_abs(number));
    },

    ToLength: function (value) {
      var len = ES.ToInteger(value);
      if (len <= 0) { return 0; } // includes converting -0 to +0
      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
      return len;
    },

    SameValue: function (a, b) {
      if (a === b) {
        // 0 === -0, but they are not identical.
        if (a === 0) { return 1 / a === 1 / b; }
        return true;
      }
      return numberIsNaN(a) && numberIsNaN(b);
    },

    SameValueZero: function (a, b) {
      // same as SameValue except for SameValueZero(+0, -0) == true
      return (a === b) || (numberIsNaN(a) && numberIsNaN(b));
    },

    IsIterable: function (o) {
      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
    },

    GetIterator: function (o) {
      if (isArguments(o)) {
        // special case support for `arguments`
        return new ArrayIterator(o, 'value');
      }
      var itFn = ES.GetMethod(o, $iterator$);
      if (!ES.IsCallable(itFn)) {
        // Better diagnostics if itFn is null or undefined
        throw new TypeError('value is not an iterable');
      }
      var it = ES.Call(itFn, o);
      if (!ES.TypeIsObject(it)) {
        throw new TypeError('bad iterator');
      }
      return it;
    },

    GetMethod: function (o, p) {
      var func = ES.ToObject(o)[p];
      if (isNullOrUndefined(func)) {
        return void 0;
      }
      if (!ES.IsCallable(func)) {
        throw new TypeError('Method not callable: ' + p);
      }
      return func;
    },

    IteratorComplete: function (iterResult) {
      return !!iterResult.done;
    },

    IteratorClose: function (iterator, completionIsThrow) {
      var returnMethod = ES.GetMethod(iterator, 'return');
      if (returnMethod === void 0) {
        return;
      }
      var innerResult, innerException;
      try {
        innerResult = ES.Call(returnMethod, iterator);
      } catch (e) {
        innerException = e;
      }
      if (completionIsThrow) {
        return;
      }
      if (innerException) {
        throw innerException;
      }
      if (!ES.TypeIsObject(innerResult)) {
        throw new TypeError("Iterator's return method returned a non-object.");
      }
    },

    IteratorNext: function (it) {
      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
      if (!ES.TypeIsObject(result)) {
        throw new TypeError('bad iterator');
      }
      return result;
    },

    IteratorStep: function (it) {
      var result = ES.IteratorNext(it);
      var done = ES.IteratorComplete(result);
      return done ? false : result;
    },

    Construct: function (C, args, newTarget, isES6internal) {
      var target = typeof newTarget === 'undefined' ? C : newTarget;

      if (!isES6internal && Reflect.construct) {
        // Try to use Reflect.construct if available
        return Reflect.construct(C, args, target);
      }
      // OK, we have to fake it.  This will only work if the
      // C.[[ConstructorKind]] == "base" -- but that's the only
      // kind we can make in ES5 code anyway.

      // OrdinaryCreateFromConstructor(target, "%ObjectPrototype%")
      var proto = target.prototype;
      if (!ES.TypeIsObject(proto)) {
        proto = Object.prototype;
      }
      var obj = create(proto);
      // Call the constructor.
      var result = ES.Call(C, obj, args);
      return ES.TypeIsObject(result) ? result : obj;
    },

    SpeciesConstructor: function (O, defaultConstructor) {
      var C = O.constructor;
      if (C === void 0) {
        return defaultConstructor;
      }
      if (!ES.TypeIsObject(C)) {
        throw new TypeError('Bad constructor');
      }
      var S = C[symbolSpecies];
      if (isNullOrUndefined(S)) {
        return defaultConstructor;
      }
      if (!ES.IsConstructor(S)) {
        throw new TypeError('Bad @@species');
      }
      return S;
    },

    CreateHTML: function (string, tag, attribute, value) {
      var S = ES.ToString(string);
      var p1 = '<' + tag;
      if (attribute !== '') {
        var V = ES.ToString(value);
        var escapedV = V.replace(/"/g, '&quot;');
        p1 += ' ' + attribute + '="' + escapedV + '"';
      }
      var p2 = p1 + '>';
      var p3 = p2 + S;
      return p3 + '</' + tag + '>';
    },

    IsRegExp: function IsRegExp(argument) {
      if (!ES.TypeIsObject(argument)) {
        return false;
      }
      var isRegExp = argument[Symbol.match];
      if (typeof isRegExp !== 'undefined') {
        return !!isRegExp;
      }
      return Type.regex(argument);
    },

    ToString: function ToString(string) {
      if (hasSymbols && _toString(string) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return $String(string);
    }
  };

  // Well-known Symbol shims
  if (supportsDescriptors && hasSymbols) {
    var defineWellKnownSymbol = function defineWellKnownSymbol(name) {
      if (Type.symbol(Symbol[name])) {
        return Symbol[name];
      }
      // eslint-disable-next-line no-restricted-properties
      var sym = Symbol['for']('Symbol.' + name);
      Object.defineProperty(Symbol, name, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: sym
      });
      return sym;
    };
    if (!Type.symbol(Symbol.search)) {
      var symbolSearch = defineWellKnownSymbol('search');
      var originalSearch = String.prototype.search;
      defineProperty(RegExp.prototype, symbolSearch, function search(string) {
        return ES.Call(originalSearch, string, [this]);
      });
      var searchShim = function search(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(regexp)) {
          var searcher = ES.GetMethod(regexp, symbolSearch);
          if (typeof searcher !== 'undefined') {
            return ES.Call(searcher, regexp, [O]);
          }
        }
        return ES.Call(originalSearch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'search', searchShim);
    }
    if (!Type.symbol(Symbol.replace)) {
      var symbolReplace = defineWellKnownSymbol('replace');
      var originalReplace = String.prototype.replace;
      defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {
        return ES.Call(originalReplace, string, [this, replaceValue]);
      });
      var replaceShim = function replace(searchValue, replaceValue) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(searchValue)) {
          var replacer = ES.GetMethod(searchValue, symbolReplace);
          if (typeof replacer !== 'undefined') {
            return ES.Call(replacer, searchValue, [O, replaceValue]);
          }
        }
        return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);
      };
      overrideNative(String.prototype, 'replace', replaceShim);
    }
    if (!Type.symbol(Symbol.split)) {
      var symbolSplit = defineWellKnownSymbol('split');
      var originalSplit = String.prototype.split;
      defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {
        return ES.Call(originalSplit, string, [this, limit]);
      });
      var splitShim = function split(separator, limit) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(separator)) {
          var splitter = ES.GetMethod(separator, symbolSplit);
          if (typeof splitter !== 'undefined') {
            return ES.Call(splitter, separator, [O, limit]);
          }
        }
        return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);
      };
      overrideNative(String.prototype, 'split', splitShim);
    }
    var symbolMatchExists = Type.symbol(Symbol.match);
    var stringMatchIgnoresSymbolMatch = symbolMatchExists && (function () {
      // Firefox 41, through Nightly 45 has Symbol.match, but String#match ignores it.
      // Firefox 40 and below have Symbol.match but String#match works fine.
      var o = {};
      o[Symbol.match] = function () { return 42; };
      return 'a'.match(o) !== 42;
    }());
    if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {
      var symbolMatch = defineWellKnownSymbol('match');

      var originalMatch = String.prototype.match;
      defineProperty(RegExp.prototype, symbolMatch, function match(string) {
        return ES.Call(originalMatch, string, [this]);
      });

      var matchShim = function match(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(regexp)) {
          var matcher = ES.GetMethod(regexp, symbolMatch);
          if (typeof matcher !== 'undefined') {
            return ES.Call(matcher, regexp, [O]);
          }
        }
        return ES.Call(originalMatch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'match', matchShim);
    }
  }

  var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {
    Value.preserveToString(replacement, original);
    if (Object.setPrototypeOf) {
      // sets up proper prototype chain where possible
      Object.setPrototypeOf(original, replacement);
    }
    if (supportsDescriptors) {
      _forEach(Object.getOwnPropertyNames(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        Value.proxy(original, key, replacement);
      });
    } else {
      _forEach(Object.keys(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        replacement[key] = original[key];
      });
    }
    replacement.prototype = original.prototype;
    Value.redefine(original.prototype, 'constructor', replacement);
  };

  var defaultSpeciesGetter = function () { return this; };
  var addDefaultSpecies = function (C) {
    if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
      Value.getter(C, symbolSpecies, defaultSpeciesGetter);
    }
  };

  var addIterator = function (prototype, impl) {
    var implementation = impl || function iterator() { return this; };
    defineProperty(prototype, $iterator$, implementation);
    if (!prototype[$iterator$] && Type.symbol($iterator$)) {
      // implementations are buggy when $iterator$ is a Symbol
      prototype[$iterator$] = implementation;
    }
  };

  var createDataProperty = function createDataProperty(object, name, value) {
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };
  var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {
    createDataProperty(object, name, value);
    if (!ES.SameValue(object[name], value)) {
      throw new TypeError('property is nonconfigurable');
    }
  };

  var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {
    // This is an es5 approximation to es6 construct semantics.  in es6,
    // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)
    // just sets the internal variable NewTarget (in es6 syntax `new.target`)
    // to Foo and then returns Foo().

    // Many ES6 object then have constructors of the form:
    // 1. If NewTarget is undefined, throw a TypeError exception
    // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)

    // So we're going to emulate those first two steps.
    if (!ES.TypeIsObject(o)) {
      throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);
    }
    var proto = defaultNewTarget.prototype;
    if (!ES.TypeIsObject(proto)) {
      proto = defaultProto;
    }
    var obj = create(proto);
    for (var name in slots) {
      if (_hasOwnProperty(slots, name)) {
        var value = slots[name];
        defineProperty(obj, name, value, true);
      }
    }
    return obj;
  };

  // Firefox 31 reports this function's length as 0
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
  if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
    var originalFromCodePoint = String.fromCodePoint;
    overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) {
      return ES.Call(originalFromCodePoint, this, arguments);
    });
  }

  var StringShims = {
    fromCodePoint: function fromCodePoint(codePoints) {
      var result = [];
      var next;
      for (var i = 0, length = arguments.length; i < length; i++) {
        next = Number(arguments[i]);
        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
          throw new RangeError('Invalid code point ' + next);
        }

        if (next < 0x10000) {
          _push(result, String.fromCharCode(next));
        } else {
          next -= 0x10000;
          _push(result, String.fromCharCode((next >> 10) + 0xD800));
          _push(result, String.fromCharCode((next % 0x400) + 0xDC00));
        }
      }
      return _join(result, '');
    },

    raw: function raw(template) {
      var numberOfSubstitutions = arguments.length - 1;
      var cooked = ES.ToObject(template, 'bad template');
      var raw = ES.ToObject(cooked.raw, 'bad raw value');
      var len = raw.length;
      var literalSegments = ES.ToLength(len);
      if (literalSegments <= 0) {
        return '';
      }

      var stringElements = [];
      var nextIndex = 0;
      var nextKey, next, nextSeg, nextSub;
      while (nextIndex < literalSegments) {
        nextKey = ES.ToString(nextIndex);
        nextSeg = ES.ToString(raw[nextKey]);
        _push(stringElements, nextSeg);
        if (nextIndex + 1 >= literalSegments) {
          break;
        }
        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';
        nextSub = ES.ToString(next);
        _push(stringElements, nextSub);
        nextIndex += 1;
      }
      return _join(stringElements, '');
    }
  };
  if (String.raw && String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {
    // IE 11 TP has a broken String.raw implementation
    overrideNative(String, 'raw', StringShims.raw);
  }
  defineProperties(String, StringShims);

  // Fast repeat, uses the `Exponentiation by squaring` algorithm.
  // Perf: http://jsperf.com/string-repeat2/2
  var stringRepeat = function repeat(s, times) {
    if (times < 1) { return ''; }
    if (times % 2) { return repeat(s, times - 1) + s; }
    var half = repeat(s, times / 2);
    return half + half;
  };
  var stringMaxLength = Infinity;

  var StringPrototypeShims = {
    repeat: function repeat(times) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var numTimes = ES.ToInteger(times);
      if (numTimes < 0 || numTimes >= stringMaxLength) {
        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
      }
      return stringRepeat(thisStr, numTimes);
    },

    startsWith: function startsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "startsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      var start = _max(ES.ToInteger(position), 0);
      return _strSlice(S, start, start + searchStr.length) === searchStr;
    },

    endsWith: function endsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "endsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var len = S.length;
      var endPosition;
      if (arguments.length > 1) {
        endPosition = arguments[1];
      }
      var pos = typeof endPosition === 'undefined' ? len : ES.ToInteger(endPosition);
      var end = _min(_max(pos, 0), len);
      return _strSlice(S, end - searchStr.length, end) === searchStr;
    },

    includes: function includes(searchString) {
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('"includes" does not accept a RegExp');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      // Somehow this trick makes method 100% compat with the spec.
      return _indexOf(this, searchStr, position) !== -1;
    },

    codePointAt: function codePointAt(pos) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var position = ES.ToInteger(pos);
      var length = thisStr.length;
      if (position >= 0 && position < length) {
        var first = thisStr.charCodeAt(position);
        var isEnd = position + 1 === length;
        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
        var second = thisStr.charCodeAt(position + 1);
        if (second < 0xDC00 || second > 0xDFFF) { return first; }
        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
      }
    }
  };
  if (String.prototype.includes && 'a'.includes('a', Infinity) !== false) {
    overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
  }

  if (String.prototype.startsWith && String.prototype.endsWith) {
    var startsWithRejectsRegex = throwsError(function () {
      /* throws if spec-compliant */
      return '/a/'.startsWith(/a/);
    });
    var startsWithHandlesInfinity = valueOrFalseIfThrows(function () {
      return 'abc'.startsWith('a', Infinity) === false;
    });
    if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {
      // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
  }
  if (hasSymbols) {
    var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.startsWith(re);
    });
    if (!startsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
    }
    var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.endsWith(re);
    });
    if (!endsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
    var includesSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.includes(re);
    });
    if (!includesSupportsSymbolMatch) {
      overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
    }
  }

  defineProperties(String.prototype, StringPrototypeShims);

  // whitespace from: http://es5.github.io/#x15.5.4.20
  // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
  var ws = [
    '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
    '\u2029\uFEFF'
  ].join('');
  var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
  var trimShim = function trim() {
    return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, '');
  };
  var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
  var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
  var isBadHexRegex = /^[-+]0x[0-9a-f]+$/i;
  var hasStringTrimBug = nonWS.trim().length !== nonWS.length;
  defineProperty(String.prototype, 'trim', trimShim, hasStringTrimBug);

  // Given an argument x, it will return an IteratorResult object,
  // with value set to x and done to false.
  // Given no arguments, it will return an iterator completion object.
  var iteratorResult = function (x) {
    return { value: x, done: arguments.length === 0 };
  };

  // see http://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype-@@iterator
  var StringIterator = function (s) {
    ES.RequireObjectCoercible(s);
    this._s = ES.ToString(s);
    this._i = 0;
  };
  StringIterator.prototype.next = function () {
    var s = this._s;
    var i = this._i;
    if (typeof s === 'undefined' || i >= s.length) {
      this._s = void 0;
      return iteratorResult();
    }
    var first = s.charCodeAt(i);
    var second, len;
    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
      len = 1;
    } else {
      second = s.charCodeAt(i + 1);
      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
    }
    this._i = i + len;
    return iteratorResult(s.substr(i, len));
  };
  addIterator(StringIterator.prototype);
  addIterator(String.prototype, function () {
    return new StringIterator(this);
  });

  var ArrayShims = {
    from: function from(items) {
      var C = this;
      var mapFn;
      if (arguments.length > 1) {
        mapFn = arguments[1];
      }
      var mapping, T;
      if (typeof mapFn === 'undefined') {
        mapping = false;
      } else {
        if (!ES.IsCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }
        if (arguments.length > 2) {
          T = arguments[2];
        }
        mapping = true;
      }

      // Note that that Arrays will use ArrayIterator:
      // https://bugs.ecmascript.org/show_bug.cgi?id=2416
      var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== 'undefined';

      var length, result, i;
      if (usingIterator) {
        result = ES.IsConstructor(C) ? Object(new C()) : [];
        var iterator = ES.GetIterator(items);
        var next, nextValue;

        i = 0;
        while (true) {
          next = ES.IteratorStep(iterator);
          if (next === false) {
            break;
          }
          nextValue = next.value;
          try {
            if (mapping) {
              nextValue = typeof T === 'undefined' ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);
            }
            result[i] = nextValue;
          } catch (e) {
            ES.IteratorClose(iterator, true);
            throw e;
          }
          i += 1;
        }
        length = i;
      } else {
        var arrayLike = ES.ToObject(items);
        length = ES.ToLength(arrayLike.length);
        result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
        var value;
        for (i = 0; i < length; ++i) {
          value = arrayLike[i];
          if (mapping) {
            value = typeof T === 'undefined' ? mapFn(value, i) : _call(mapFn, T, value, i);
          }
          createDataPropertyOrThrow(result, i, value);
        }
      }

      result.length = length;
      return result;
    },

    of: function of() {
      var len = arguments.length;
      var C = this;
      var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
      for (var k = 0; k < len; ++k) {
        createDataPropertyOrThrow(A, k, arguments[k]);
      }
      A.length = len;
      return A;
    }
  };
  defineProperties(Array, ArrayShims);
  addDefaultSpecies(Array);

  // Our ArrayIterator is private; see
  // https://github.com/paulmillr/es6-shim/issues/252
  ArrayIterator = function (array, kind) {
    this.i = 0;
    this.array = array;
    this.kind = kind;
  };

  defineProperties(ArrayIterator.prototype, {
    next: function () {
      var i = this.i;
      var array = this.array;
      if (!(this instanceof ArrayIterator)) {
        throw new TypeError('Not an ArrayIterator');
      }
      if (typeof array !== 'undefined') {
        var len = ES.ToLength(array.length);
        if (i < len) {
        //for (; i < len; i++) {
          var kind = this.kind;
          var retval;
          if (kind === 'key') {
            retval = i;
          } else if (kind === 'value') {
            retval = array[i];
          } else if (kind === 'entry') {
            retval = [i, array[i]];
          }
          this.i = i + 1;
          return iteratorResult(retval);
        }
      }
      this.array = void 0;
      return iteratorResult();
    }
  });
  addIterator(ArrayIterator.prototype);

  /*
  var orderKeys = function orderKeys(a, b) {
    var aNumeric = String(ES.ToInteger(a)) === a;
    var bNumeric = String(ES.ToInteger(b)) === b;
    if (aNumeric && bNumeric) {
      return b - a;
    } else if (aNumeric && !bNumeric) {
      return -1;
    } else if (!aNumeric && bNumeric) {
      return 1;
    } else {
      return a.localeCompare(b);
    }
  };

  var getAllKeys = function getAllKeys(object) {
    var ownKeys = [];
    var keys = [];

    for (var key in object) {
      _push(_hasOwnProperty(object, key) ? ownKeys : keys, key);
    }
    _sort(ownKeys, orderKeys);
    _sort(keys, orderKeys);

    return _concat(ownKeys, keys);
  };
  */

  // note: this is positioned here because it depends on ArrayIterator
  var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {
    // Detects a bug in Webkit nightly r181886
    var Foo = function Foo(len) { this.length = len; };
    Foo.prototype = [];
    var fooArr = Array.of.apply(Foo, [1, 2]);
    return fooArr instanceof Foo && fooArr.length === 2;
  }());
  if (!arrayOfSupportsSubclassing) {
    overrideNative(Array, 'of', ArrayShims.of);
  }

  var ArrayPrototypeShims = {
    copyWithin: function copyWithin(target, start) {
      var o = ES.ToObject(this);
      var len = ES.ToLength(o.length);
      var relativeTarget = ES.ToInteger(target);
      var relativeStart = ES.ToInteger(start);
      var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
      var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var relativeEnd = typeof end === 'undefined' ? len : ES.ToInteger(end);
      var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);
      var count = _min(finalItem - from, len - to);
      var direction = 1;
      if (from < to && to < (from + count)) {
        direction = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count > 0) {
        if (from in o) {
          o[to] = o[from];
        } else {
          delete o[to];
        }
        from += direction;
        to += direction;
        count -= 1;
      }
      return o;
    },

    fill: function fill(value) {
      var start;
      if (arguments.length > 1) {
        start = arguments[1];
      }
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var O = ES.ToObject(this);
      var len = ES.ToLength(O.length);
      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
      end = ES.ToInteger(typeof end === 'undefined' ? len : end);

      var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
      var relativeEnd = end < 0 ? len + end : end;

      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
        O[i] = value;
      }
      return O;
    },

    find: function find(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#find: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0, value; i < length; i++) {
        value = list[i];
        if (thisArg) {
          if (_call(predicate, thisArg, value, i, list)) {
            return value;
          }
        } else if (predicate(value, i, list)) {
          return value;
        }
      }
    },

    findIndex: function findIndex(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#findIndex: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0; i < length; i++) {
        if (thisArg) {
          if (_call(predicate, thisArg, list[i], i, list)) {
            return i;
          }
        } else if (predicate(list[i], i, list)) {
          return i;
        }
      }
      return -1;
    },

    keys: function keys() {
      return new ArrayIterator(this, 'key');
    },

    values: function values() {
      return new ArrayIterator(this, 'value');
    },

    entries: function entries() {
      return new ArrayIterator(this, 'entry');
    }
  };
  // Safari 7.1 defines Array#keys and Array#entries natively,
  // but the resulting ArrayIterator objects don't have a "next" method.
  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
    delete Array.prototype.keys;
  }
  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
    delete Array.prototype.entries;
  }

  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
    defineProperties(Array.prototype, {
      values: Array.prototype[$iterator$]
    });
    if (Type.symbol(Symbol.unscopables)) {
      Array.prototype[Symbol.unscopables].values = true;
    }
  }
  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
  if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {
    var originalArrayPrototypeValues = Array.prototype.values;
    overrideNative(Array.prototype, 'values', function values() { return ES.Call(originalArrayPrototypeValues, this, arguments); });
    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
  }
  defineProperties(Array.prototype, ArrayPrototypeShims);

  if (1 / [true].indexOf(true, -0) < 0) {
    // indexOf when given a position arg of -0 should return +0.
    // https://github.com/tc39/ecma262/pull/316
    defineProperty(Array.prototype, 'indexOf', function indexOf(searchElement) {
      var value = _arrayIndexOfApply(this, arguments);
      if (value === 0 && (1 / value) < 0) {
        return 0;
      }
      return value;
    }, true);
  }

  addIterator(Array.prototype, function () { return this.values(); });
  // Chrome defines keys/values/entries on Array, but doesn't give us
  // any way to identify its iterator.  So add our own shimmed field.
  if (Object.getPrototypeOf) {
    addIterator(Object.getPrototypeOf([].values()));
  }

  // note: this is positioned here because it relies on Array#entries
  var arrayFromSwallowsNegativeLengths = (function () {
    // Detects a Firefox bug in v32
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
    return valueOrFalseIfThrows(function () {
      return Array.from({ length: -1 }).length === 0;
    });
  }());
  var arrayFromHandlesIterables = (function () {
    // Detects a bug in Webkit nightly r181886
    var arr = Array.from([0].entries());
    return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
  }());
  if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
    overrideNative(Array, 'from', ArrayShims.from);
  }
  var arrayFromHandlesUndefinedMapFunction = (function () {
    // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,
    // but the spec doesn't care if it's provided or not - undefined doesn't throw.
    return valueOrFalseIfThrows(function () {
      return Array.from([0], void 0);
    });
  }());
  if (!arrayFromHandlesUndefinedMapFunction) {
    var origArrayFrom = Array.from;
    overrideNative(Array, 'from', function from(items) {
      if (arguments.length > 1 && typeof arguments[1] !== 'undefined') {
        return ES.Call(origArrayFrom, this, arguments);
      } else {
        return _call(origArrayFrom, this, items);
      }
    });
  }

  var int32sAsOne = -(Math.pow(2, 32) - 1);
  var toLengthsCorrectly = function (method, reversed) {
    var obj = { length: int32sAsOne };
    obj[reversed ? (obj.length >>> 0) - 1 : 0] = true;
    return valueOrFalseIfThrows(function () {
      _call(method, obj, function () {
        // note: in nonconforming browsers, this will be called
        // -1 >>> 0 times, which is 4294967295, so the throw matters.
        throw new RangeError('should not reach here');
      }, []);
      return true;
    });
  };
  if (!toLengthsCorrectly(Array.prototype.forEach)) {
    var originalForEach = Array.prototype.forEach;
    overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {
      return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.map)) {
    var originalMap = Array.prototype.map;
    overrideNative(Array.prototype, 'map', function map(callbackFn) {
      return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.filter)) {
    var originalFilter = Array.prototype.filter;
    overrideNative(Array.prototype, 'filter', function filter(callbackFn) {
      return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.some)) {
    var originalSome = Array.prototype.some;
    overrideNative(Array.prototype, 'some', function some(callbackFn) {
      return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.every)) {
    var originalEvery = Array.prototype.every;
    overrideNative(Array.prototype, 'every', function every(callbackFn) {
      return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.reduce)) {
    var originalReduce = Array.prototype.reduce;
    overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {
      return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
    var originalReduceRight = Array.prototype.reduceRight;
    overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {
      return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);
    });
  }

  var lacksOctalSupport = Number('0o10') !== 8;
  var lacksBinarySupport = Number('0b10') !== 2;
  var trimsNonWhitespace = _some(nonWS, function (c) {
    return Number(c + 0 + c) === 0;
  });
  if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {
    var OrigNumber = Number;
    var binaryRegex = /^0b[01]+$/i;
    var octalRegex = /^0o[0-7]+$/i;
    // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
    var isBinary = binaryRegex.test.bind(binaryRegex);
    var isOctal = octalRegex.test.bind(octalRegex);
    var toPrimitive = function (O, hint) { // need to replace this with `es-to-primitive/es6`
      var result;
      if (typeof O.valueOf === 'function') {
        result = O.valueOf();
        if (Type.primitive(result)) {
          return result;
        }
      }
      if (typeof O.toString === 'function') {
        result = O.toString();
        if (Type.primitive(result)) {
          return result;
        }
      }
      throw new TypeError('No default value');
    };
    var hasNonWS = nonWSregex.test.bind(nonWSregex);
    var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);
    var NumberShim = (function () {
      // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.
      var NumberShim = function Number(value) {
        var primValue;
        if (arguments.length > 0) {
          primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');
        } else {
          primValue = 0;
        }
        if (typeof primValue === 'string') {
          primValue = ES.Call(trimShim, primValue);
          if (isBinary(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 2);
          } else if (isOctal(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 8);
          } else if (hasNonWS(primValue) || isBadHex(primValue)) {
            primValue = NaN;
          }
        }
        var receiver = this;
        var valueOfSucceeds = valueOrFalseIfThrows(function () {
          OrigNumber.prototype.valueOf.call(receiver);
          return true;
        });
        if (receiver instanceof NumberShim && !valueOfSucceeds) {
          return new OrigNumber(primValue);
        }
        return OrigNumber(primValue);
      };
      return NumberShim;
    }());
    wrapConstructor(OrigNumber, NumberShim, {});
    // this is necessary for ES3 browsers, where these properties are non-enumerable.
    defineProperties(NumberShim, {
      NaN: OrigNumber.NaN,
      MAX_VALUE: OrigNumber.MAX_VALUE,
      MIN_VALUE: OrigNumber.MIN_VALUE,
      NEGATIVE_INFINITY: OrigNumber.NEGATIVE_INFINITY,
      POSITIVE_INFINITY: OrigNumber.POSITIVE_INFINITY
    });
    /* eslint-disable no-undef, no-global-assign */
    Number = NumberShim;
    Value.redefine(globals, 'Number', NumberShim);
    /* eslint-enable no-undef, no-global-assign */
  }

  var maxSafeInteger = Math.pow(2, 53) - 1;
  defineProperties(Number, {
    MAX_SAFE_INTEGER: maxSafeInteger,
    MIN_SAFE_INTEGER: -maxSafeInteger,
    EPSILON: 2.220446049250313e-16,

    parseInt: globals.parseInt,
    parseFloat: globals.parseFloat,

    isFinite: numberIsFinite,

    isInteger: function isInteger(value) {
      return numberIsFinite(value) && ES.ToInteger(value) === value;
    },

    isSafeInteger: function isSafeInteger(value) {
      return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
    },

    isNaN: numberIsNaN
  });
  // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)
  defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);

  // Work around bugs in Array#find and Array#findIndex -- early
  // implementations skipped holes in sparse arrays. (Note that the
  // implementations of find/findIndex indirectly use shimmed
  // methods of Number, so this test has to happen down here.)
  /* eslint-disable no-sparse-arrays */
  if ([, 1].find(function () { return true; }) === 1) {
    overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);
  }
  if ([, 1].findIndex(function () { return true; }) !== 0) {
    overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);
  }
  /* eslint-enable no-sparse-arrays */

  var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
  var ensureEnumerable = function ensureEnumerable(obj, prop) {
    if (supportsDescriptors && isEnumerableOn(obj, prop)) {
      Object.defineProperty(obj, prop, { enumerable: false });
    }
  };
  var sliceArgs = function sliceArgs() {
    // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
    // and https://gist.github.com/WebReflection/4327762cb87a8c634a29
    var initial = Number(this);
    var len = arguments.length;
    var desiredArgCount = len - initial;
    var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
    for (var i = initial; i < len; ++i) {
      args[i - initial] = arguments[i];
    }
    return args;
  };
  var assignTo = function assignTo(source) {
    return function assignToSource(target, key) {
      target[key] = source[key];
      return target;
    };
  };
  var assignReducer = function (target, source) {
    var sourceKeys = keys(Object(source));
    var symbols;
    if (ES.IsCallable(Object.getOwnPropertySymbols)) {
      symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
    }
    return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);
  };

  var ObjectShims = {
    // 19.1.3.1
    assign: function (target, source) {
      var to = ES.ToObject(target, 'Cannot convert undefined or null to object');
      return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);
    },

    // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865
    is: function is(a, b) {
      return ES.SameValue(a, b);
    }
  };
  var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {
    // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
    // which is 72% slower than our shim, and Firefox 40's native implementation.
    var thrower = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(thrower, 'xy');
    } catch (e) {
      return thrower[1] === 'y';
    }
  }());
  if (assignHasPendingExceptions) {
    overrideNative(Object, 'assign', ObjectShims.assign);
  }
  defineProperties(Object, ObjectShims);

  if (supportsDescriptors) {
    var ES5ObjectShims = {
      // 19.1.3.9
      // shim from https://gist.github.com/WebReflection/5593554
      setPrototypeOf: (function (Object, magic) {
        var set;

        var checkArgs = function (O, proto) {
          if (!ES.TypeIsObject(O)) {
            throw new TypeError('cannot set prototype on a non-object');
          }
          if (!(proto === null || ES.TypeIsObject(proto))) {
            throw new TypeError('can only set prototype to an object or null' + proto);
          }
        };

        var setPrototypeOf = function (O, proto) {
          checkArgs(O, proto);
          _call(set, O, proto);
          return O;
        };

        try {
          // this works already in Firefox and Safari
          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
          _call(set, {}, null);
        } catch (e) {
          if (Object.prototype !== {}[magic]) {
            // IE < 11 cannot be shimmed
            return;
          }
          // probably Chrome or some old Mobile stock browser
          set = function (proto) {
            this[magic] = proto;
          };
          // please note that this will **not** work
          // in those browsers that do not inherit
          // __proto__ by mistake from Object.prototype
          // in these cases we should probably throw an error
          // or at least be informed about the issue
          setPrototypeOf.polyfill = setPrototypeOf(
            setPrototypeOf({}, null),
            Object.prototype
          ) instanceof Object;
          // setPrototypeOf.polyfill === true means it works as meant
          // setPrototypeOf.polyfill === false means it's not 100% reliable
          // setPrototypeOf.polyfill === undefined
          // or
          // setPrototypeOf.polyfill ==  null means it's not a polyfill
          // which means it works as expected
          // we can even delete Object.prototype.__proto__;
        }
        return setPrototypeOf;
      }(Object, '__proto__'))
    };

    defineProperties(Object, ES5ObjectShims);
  }

  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
  // but Object.create(null) does.
  if (Object.setPrototypeOf && Object.getPrototypeOf &&
      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
      Object.getPrototypeOf(Object.create(null)) === null) {
    (function () {
      var FAKENULL = Object.create(null);
      var gpo = Object.getPrototypeOf;
      var spo = Object.setPrototypeOf;
      Object.getPrototypeOf = function (o) {
        var result = gpo(o);
        return result === FAKENULL ? null : result;
      };
      Object.setPrototypeOf = function (o, p) {
        var proto = p === null ? FAKENULL : p;
        return spo(o, proto);
      };
      Object.setPrototypeOf.polyfill = false;
    }());
  }

  var objectKeysAcceptsPrimitives = !throwsError(function () { return Object.keys('foo'); });
  if (!objectKeysAcceptsPrimitives) {
    var originalObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      return originalObjectKeys(ES.ToObject(value));
    });
    keys = Object.keys;
  }
  var objectKeysRejectsRegex = throwsError(function () { return Object.keys(/a/g); });
  if (objectKeysRejectsRegex) {
    var regexRejectingObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      if (Type.regex(value)) {
        var regexKeys = [];
        for (var k in value) {
          if (_hasOwnProperty(value, k)) {
            _push(regexKeys, k);
          }
        }
        return regexKeys;
      }
      return regexRejectingObjectKeys(value);
    });
    keys = Object.keys;
  }

  if (Object.getOwnPropertyNames) {
    var objectGOPNAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyNames('foo'); });
    if (!objectGOPNAcceptsPrimitives) {
      var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
      overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
        var val = ES.ToObject(value);
        if (_toString(val) === '[object Window]') {
          try {
            return originalObjectGetOwnPropertyNames(val);
          } catch (e) {
            // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
            return _concat([], cachedWindowNames);
          }
        }
        return originalObjectGetOwnPropertyNames(val);
      });
    }
  }
  if (Object.getOwnPropertyDescriptor) {
    var objectGOPDAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyDescriptor('foo', 'bar'); });
    if (!objectGOPDAcceptsPrimitives) {
      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
      });
    }
  }
  if (Object.seal) {
    var objectSealAcceptsPrimitives = !throwsError(function () { return Object.seal('foo'); });
    if (!objectSealAcceptsPrimitives) {
      var originalObjectSeal = Object.seal;
      overrideNative(Object, 'seal', function seal(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectSeal(value);
      });
    }
  }
  if (Object.isSealed) {
    var objectIsSealedAcceptsPrimitives = !throwsError(function () { return Object.isSealed('foo'); });
    if (!objectIsSealedAcceptsPrimitives) {
      var originalObjectIsSealed = Object.isSealed;
      overrideNative(Object, 'isSealed', function isSealed(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsSealed(value);
      });
    }
  }
  if (Object.freeze) {
    var objectFreezeAcceptsPrimitives = !throwsError(function () { return Object.freeze('foo'); });
    if (!objectFreezeAcceptsPrimitives) {
      var originalObjectFreeze = Object.freeze;
      overrideNative(Object, 'freeze', function freeze(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectFreeze(value);
      });
    }
  }
  if (Object.isFrozen) {
    var objectIsFrozenAcceptsPrimitives = !throwsError(function () { return Object.isFrozen('foo'); });
    if (!objectIsFrozenAcceptsPrimitives) {
      var originalObjectIsFrozen = Object.isFrozen;
      overrideNative(Object, 'isFrozen', function isFrozen(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsFrozen(value);
      });
    }
  }
  if (Object.preventExtensions) {
    var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { return Object.preventExtensions('foo'); });
    if (!objectPreventExtensionsAcceptsPrimitives) {
      var originalObjectPreventExtensions = Object.preventExtensions;
      overrideNative(Object, 'preventExtensions', function preventExtensions(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectPreventExtensions(value);
      });
    }
  }
  if (Object.isExtensible) {
    var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { return Object.isExtensible('foo'); });
    if (!objectIsExtensibleAcceptsPrimitives) {
      var originalObjectIsExtensible = Object.isExtensible;
      overrideNative(Object, 'isExtensible', function isExtensible(value) {
        if (!ES.TypeIsObject(value)) { return false; }
        return originalObjectIsExtensible(value);
      });
    }
  }
  if (Object.getPrototypeOf) {
    var objectGetProtoAcceptsPrimitives = !throwsError(function () { return Object.getPrototypeOf('foo'); });
    if (!objectGetProtoAcceptsPrimitives) {
      var originalGetProto = Object.getPrototypeOf;
      overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {
        return originalGetProto(ES.ToObject(value));
      });
    }
  }

  var hasFlags = supportsDescriptors && (function () {
    var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');
    return desc && ES.IsCallable(desc.get);
  }());
  if (supportsDescriptors && !hasFlags) {
    var regExpFlagsGetter = function flags() {
      if (!ES.TypeIsObject(this)) {
        throw new TypeError('Method called on incompatible type: must be an object.');
      }
      var result = '';
      if (this.global) {
        result += 'g';
      }
      if (this.ignoreCase) {
        result += 'i';
      }
      if (this.multiline) {
        result += 'm';
      }
      if (this.unicode) {
        result += 'u';
      }
      if (this.sticky) {
        result += 'y';
      }
      return result;
    };

    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
  }

  var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function () {
    return String(new RegExp(/a/g, 'i')) === '/a/i';
  });
  var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && (function () {
    // Edge 0.12 supports flags fully, but does not support Symbol.match
    var regex = /./;
    regex[Symbol.match] = false;
    return RegExp(regex) === regex;
  }());

  var regexToStringIsGeneric = valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'abc' }) === '/abc/';
  });
  var regexToStringSupportsGenericFlags = regexToStringIsGeneric && valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'a', flags: 'b' }) === '/a/b';
  });
  if (!regexToStringIsGeneric || !regexToStringSupportsGenericFlags) {
    var origRegExpToString = RegExp.prototype.toString;
    defineProperty(RegExp.prototype, 'toString', function toString() {
      var R = ES.RequireObjectCoercible(this);
      if (Type.regex(R)) {
        return _call(origRegExpToString, R);
      }
      var pattern = $String(R.source);
      var flags = $String(R.flags);
      return '/' + pattern + '/' + flags;
    }, true);
    Value.preserveToString(RegExp.prototype.toString, origRegExpToString);
  }

  if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {
    var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get;
    var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'source') || {};
    var legacySourceGetter = function () {
      // prior to it being a getter, it's own + nonconfigurable
      return this.source;
    };
    var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;

    var OrigRegExp = RegExp;
    var RegExpShim = (function () {
      return function RegExp(pattern, flags) {
        var patternIsRegExp = ES.IsRegExp(pattern);
        var calledWithNew = this instanceof RegExp;
        if (!calledWithNew && patternIsRegExp && typeof flags === 'undefined' && pattern.constructor === RegExp) {
          return pattern;
        }

        var P = pattern;
        var F = flags;
        if (Type.regex(pattern)) {
          P = ES.Call(sourceGetter, pattern);
          F = typeof flags === 'undefined' ? ES.Call(flagsGetter, pattern) : flags;
          return new RegExp(P, F);
        } else if (patternIsRegExp) {
          P = pattern.source;
          F = typeof flags === 'undefined' ? pattern.flags : flags;
        }
        return new OrigRegExp(pattern, flags);
      };
    }());
    wrapConstructor(OrigRegExp, RegExpShim, {
      $input: true // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
    });
    /* eslint-disable no-undef, no-global-assign */
    RegExp = RegExpShim;
    Value.redefine(globals, 'RegExp', RegExpShim);
    /* eslint-enable no-undef, no-global-assign */
  }

  if (supportsDescriptors) {
    var regexGlobals = {
      input: '$_',
      lastMatch: '$&',
      lastParen: '$+',
      leftContext: '$`',
      rightContext: '$\''
    };
    _forEach(keys(regexGlobals), function (prop) {
      if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
        Value.getter(RegExp, regexGlobals[prop], function get() {
          return RegExp[prop];
        });
      }
    });
  }
  addDefaultSpecies(RegExp);

  var inverseEpsilon = 1 / Number.EPSILON;
  var roundTiesToEven = function roundTiesToEven(n) {
    // Even though this reduces down to `return n`, it takes advantage of built-in rounding.
    return (n + inverseEpsilon) - inverseEpsilon;
  };
  var BINARY_32_EPSILON = Math.pow(2, -23);
  var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
  var BINARY_32_MIN_VALUE = Math.pow(2, -126);
  var E = Math.E;
  var LOG2E = Math.LOG2E;
  var LOG10E = Math.LOG10E;
  var numberCLZ = Number.prototype.clz;
  delete Number.prototype.clz; // Safari 8 has Number#clz

  var MathShims = {
    acosh: function acosh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || value < 1) { return NaN; }
      if (x === 1) { return 0; }
      if (x === Infinity) { return x; }

      var xInvSquared = 1 / (x * x);
      if (x < 2) {
        return _log1p(x - 1 + (_sqrt(1 - xInvSquared) * x));
      }
      var halfX = x / 2;
      return _log1p(halfX + (_sqrt(1 - xInvSquared) * halfX) - 1) + (1 / LOG2E);
    },

    asinh: function asinh(value) {
      var x = Number(value);
      if (x === 0 || !globalIsFinite(x)) {
        return x;
      }

      var a = _abs(x);
      var aSquared = a * a;
      var s = _sign(x);
      if (a < 1) {
        return s * _log1p(a + (aSquared / (_sqrt(aSquared + 1) + 1)));
      }
      return s * (_log1p((a / 2) + (_sqrt(1 + (1 / aSquared)) * a / 2) - 1) + (1 / LOG2E));
    },

    atanh: function atanh(value) {
      var x = Number(value);

      if (x === 0) { return x; }
      if (x === -1) { return -Infinity; }
      if (x === 1) { return Infinity; }
      if (numberIsNaN(x) || x < -1 || x > 1) {
        return NaN;
      }

      var a = _abs(x);
      return _sign(x) * _log1p(2 * a / (1 - a)) / 2;
    },

    cbrt: function cbrt(value) {
      var x = Number(value);
      if (x === 0) { return x; }
      var negate = x < 0;
      var result;
      if (negate) { x = -x; }
      if (x === Infinity) {
        result = Infinity;
      } else {
        result = _exp(_log(x) / 3);
        // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
        result = ((x / (result * result)) + (2 * result)) / 3;
      }
      return negate ? -result : result;
    },

    clz32: function clz32(value) {
      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
      var x = Number(value);
      var number = ES.ToUint32(x);
      if (number === 0) {
        return 32;
      }
      return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * LOG2E);
    },

    cosh: function cosh(value) {
      var x = Number(value);
      if (x === 0) { return 1; } // +0 or -0
      if (numberIsNaN(x)) { return NaN; }
      if (!globalIsFinite(x)) { return Infinity; }

      var t = _exp(_abs(x) - 1);
      return (t + (1 / (t * E * E))) * (E / 2);
    },

    expm1: function expm1(value) {
      var x = Number(value);
      if (x === -Infinity) { return -1; }
      if (!globalIsFinite(x) || x === 0) { return x; }
      if (_abs(x) > 0.5) {
        return _exp(x) - 1;
      }
      // A more precise approximation using Taylor series expansion
      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
      var t = x;
      var sum = 0;
      var n = 1;
      while (sum + t !== sum) {
        sum += t;
        n += 1;
        t *= x / n;
      }
      return sum;
    },

    hypot: function hypot(x, y) {
      var result = 0;
      var largest = 0;
      for (var i = 0; i < arguments.length; ++i) {
        var value = _abs(Number(arguments[i]));
        if (largest < value) {
          result *= (largest / value) * (largest / value);
          result += 1;
          largest = value;
        } else {
          result += value > 0 ? (value / largest) * (value / largest) : value;
        }
      }
      return largest === Infinity ? Infinity : largest * _sqrt(result);
    },

    log2: function log2(value) {
      return _log(value) * LOG2E;
    },

    log10: function log10(value) {
      return _log(value) * LOG10E;
    },

    log1p: _log1p,

    sign: _sign,

    sinh: function sinh(value) {
      var x = Number(value);
      if (!globalIsFinite(x) || x === 0) { return x; }

      var a = _abs(x);
      if (a < 1) {
        var u = Math.expm1(a);
        return _sign(x) * u * (1 + (1 / (u + 1))) / 2;
      }
      var t = _exp(a - 1);
      return _sign(x) * (t - (1 / (t * E * E))) * (E / 2);
    },

    tanh: function tanh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || x === 0) { return x; }
      // can exit early at +-20 as JS loses precision for true value at this integer
      if (x >= 20) { return 1; }
      if (x <= -20) { return -1; }

      return (Math.expm1(x) - Math.expm1(-x)) / (_exp(x) + _exp(-x));
    },

    trunc: function trunc(value) {
      var x = Number(value);
      return x < 0 ? -_floor(-x) : _floor(x);
    },

    imul: function imul(x, y) {
      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
      var a = ES.ToUint32(x);
      var b = ES.ToUint32(y);
      var ah = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return (al * bl) + ((((ah * bl) + (al * bh)) << 16) >>> 0) | 0;
    },

    fround: function fround(x) {
      var v = Number(x);
      if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
        return v;
      }
      var sign = _sign(v);
      var abs = _abs(v);
      if (abs < BINARY_32_MIN_VALUE) {
        return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
      }
      // Veltkamp's splitting (?)
      var a = (1 + (BINARY_32_EPSILON / Number.EPSILON)) * abs;
      var result = a - (a - abs);
      if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
        return sign * Infinity;
      }
      return sign * result;
    }
  };

  var withinULPDistance = function withinULPDistance(result, expected, distance) {
    return _abs(1 - (result / expected)) / Number.EPSILON < (distance || 8);
  };

  defineProperties(Math, MathShims);
  // Chrome < 40 sinh returns âˆž for large numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(710) === Infinity);
  // Chrome < 40 cosh returns âˆž for large numbers
  defineProperty(Math, 'cosh', MathShims.cosh, Math.cosh(710) === Infinity);
  // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0
  defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
  // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)
  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
  // Chrome < 54 asinh returns âˆž for large numbers and should not
  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(1e+300) === Infinity);
  // Chrome < 54 atanh incorrectly returns 0 for large numbers
  defineProperty(Math, 'atanh', MathShims.atanh, Math.atanh(1e-300) === 0);
  // Chrome 40 has an imprecise Math.tanh with very small numbers
  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
  // Chrome 40 loses Math.acosh precision with high numbers
  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
  // Chrome < 54 has an inaccurate acosh for EPSILON deltas
  defineProperty(Math, 'acosh', MathShims.acosh, !withinULPDistance(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
  // Firefox 38 on Windows
  defineProperty(Math, 'cbrt', MathShims.cbrt, !withinULPDistance(Math.cbrt(1e-300), 1e-100));
  // node 0.11 has an imprecise Math.sinh with very small numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
  var expm1OfTen = Math.expm1(10);
  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);
  // node v12.11 - v12.15 report NaN
  defineProperty(Math, 'hypot', MathShims.hypot, Math.hypot(Infinity, NaN) !== Infinity);

  var origMathRound = Math.round;
  // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12
  var roundHandlesBoundaryConditions = Math.round(0.5 - (Number.EPSILON / 4)) === 0 &&
    Math.round(-0.5 + (Number.EPSILON / 3.99)) === 1;

  // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.
  // This behavior should be governed by "round to nearest, ties to even mode"
  // see http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-type
  // These are the boundary cases where it breaks.
  var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
  var largestPositiveNumberWhereRoundBreaks = (2 * inverseEpsilon) - 1;
  var roundDoesNotIncreaseIntegers = [
    smallestPositiveNumberWhereRoundBreaks,
    largestPositiveNumberWhereRoundBreaks
  ].every(function (num) {
    return Math.round(num) === num;
  });
  defineProperty(Math, 'round', function round(x) {
    var floor = _floor(x);
    var ceil = floor === -1 ? -0 : floor + 1;
    return x - floor < 0.5 ? floor : ceil;
  }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
  Value.preserveToString(Math.round, origMathRound);

  var origImul = Math.imul;
  if (Math.imul(0xffffffff, 5) !== -5) {
    // Safari 6.1, at least, reports "0" for this value
    Math.imul = MathShims.imul;
    Value.preserveToString(Math.imul, origImul);
  }
  if (Math.imul.length !== 2) {
    // Safari 8.0.4 has a length of 1
    // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658
    overrideNative(Math, 'imul', function imul(x, y) {
      return ES.Call(origImul, Math, arguments);
    });
  }

  // Promises
  // Simplest possible implementation; use a 3rd-party library if you
  // want the best possible speed and/or long stack traces.
  var PromiseShim = (function () {
    var setTimeout = globals.setTimeout;
    // some environments don't have setTimeout - no way to shim here.
    if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }

    ES.IsPromise = function (promise) {
      if (!ES.TypeIsObject(promise)) {
        return false;
      }
      if (typeof promise._promise === 'undefined') {
        return false; // uninitialized, or missing our hidden field.
      }
      return true;
    };

    // "PromiseCapability" in the spec is what most promise implementations
    // call a "deferred".
    var PromiseCapability = function (C) {
      if (!ES.IsConstructor(C)) {
        throw new TypeError('Bad promise constructor');
      }
      var capability = this;
      var resolver = function (resolve, reject) {
        if (capability.resolve !== void 0 || capability.reject !== void 0) {
          throw new TypeError('Bad Promise implementation!');
        }
        capability.resolve = resolve;
        capability.reject = reject;
      };
      // Initialize fields to inform optimizers about the object shape.
      capability.resolve = void 0;
      capability.reject = void 0;
      capability.promise = new C(resolver);
      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
        throw new TypeError('Bad promise constructor');
      }
    };

    // find an appropriate setImmediate-alike
    var makeZeroTimeout;
    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
      makeZeroTimeout = function () {
        // from http://dbaron.org/log/20100309-faster-timeouts
        var timeouts = [];
        var messageName = 'zero-timeout-message';
        var setZeroTimeout = function (fn) {
          _push(timeouts, fn);
          window.postMessage(messageName, '*');
        };
        var handleMessage = function (event) {
          if (event.source === window && event.data === messageName) {
            event.stopPropagation();
            if (timeouts.length === 0) { return; }
            var fn = _shift(timeouts);
            fn();
          }
        };
        window.addEventListener('message', handleMessage, true);
        return setZeroTimeout;
      };
    }
    var makePromiseAsap = function () {
      // An efficient task-scheduler based on a pre-existing Promise
      // implementation, which we can use even if we override the
      // global Promise below (in order to workaround bugs)
      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
      var P = globals.Promise;
      var pr = P && P.resolve && P.resolve();
      return pr && function (task) {
        return pr.then(task);
      };
    };
    var enqueue = ES.IsCallable(globals.setImmediate) ?
      globals.setImmediate :
      typeof process === 'object' && process.nextTick ? process.nextTick : makePromiseAsap() ||
      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() : function (task) { setTimeout(task, 0); }); // fallback

    // Constants for Promise implementation
    var PROMISE_IDENTITY = function (x) { return x; };
    var PROMISE_THROWER = function (e) { throw e; };
    var PROMISE_PENDING = 0;
    var PROMISE_FULFILLED = 1;
    var PROMISE_REJECTED = 2;
    // We store fulfill/reject handlers and capabilities in a single array.
    var PROMISE_FULFILL_OFFSET = 0;
    var PROMISE_REJECT_OFFSET = 1;
    var PROMISE_CAPABILITY_OFFSET = 2;
    // This is used in an optimization for chaining promises via then.
    var PROMISE_FAKE_CAPABILITY = {};

    var enqueuePromiseReactionJob = function (handler, capability, argument) {
      enqueue(function () {
        promiseReactionJob(handler, capability, argument);
      });
    };

    var promiseReactionJob = function (handler, promiseCapability, argument) {
      var handlerResult, f;
      if (promiseCapability === PROMISE_FAKE_CAPABILITY) {
        // Fast case, when we don't actually need to chain through to a
        // (real) promiseCapability.
        return handler(argument);
      }
      try {
        handlerResult = handler(argument);
        f = promiseCapability.resolve;
      } catch (e) {
        handlerResult = e;
        f = promiseCapability.reject;
      }
      f(handlerResult);
    };

    var fulfillPromise = function (promise, value) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.fulfillReactionHandler0,
          _promise.reactionCapability0,
          value
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_FULFILL_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              value
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = value;
      _promise.state = PROMISE_FULFILLED;
      _promise.reactionLength = 0;
    };

    var rejectPromise = function (promise, reason) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.rejectReactionHandler0,
          _promise.reactionCapability0,
          reason
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_REJECT_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              reason
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = reason;
      _promise.state = PROMISE_REJECTED;
      _promise.reactionLength = 0;
    };

    var createResolvingFunctions = function (promise) {
      var alreadyResolved = false;
      var resolve = function (resolution) {
        var then;
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        if (resolution === promise) {
          return rejectPromise(promise, new TypeError('Self resolution'));
        }
        if (!ES.TypeIsObject(resolution)) {
          return fulfillPromise(promise, resolution);
        }
        try {
          then = resolution.then;
        } catch (e) {
          return rejectPromise(promise, e);
        }
        if (!ES.IsCallable(then)) {
          return fulfillPromise(promise, resolution);
        }
        enqueue(function () {
          promiseResolveThenableJob(promise, resolution, then);
        });
      };
      var reject = function (reason) {
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        return rejectPromise(promise, reason);
      };
      return { resolve: resolve, reject: reject };
    };

    var optimizedThen = function (then, thenable, resolve, reject) {
      // Optimization: since we discard the result, we can pass our
      // own then implementation a special hint to let it know it
      // doesn't have to create it.  (The PROMISE_FAKE_CAPABILITY
      // object is local to this implementation and unforgeable outside.)
      if (then === Promise$prototype$then) {
        _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);
      } else {
        _call(then, thenable, resolve, reject);
      }
    };
    var promiseResolveThenableJob = function (promise, thenable, then) {
      var resolvingFunctions = createResolvingFunctions(promise);
      var resolve = resolvingFunctions.resolve;
      var reject = resolvingFunctions.reject;
      try {
        optimizedThen(then, thenable, resolve, reject);
      } catch (e) {
        reject(e);
      }
    };

    var Promise$prototype, Promise$prototype$then;
    var Promise = (function () {
      var PromiseShim = function Promise(resolver) {
        if (!(this instanceof PromiseShim)) {
          throw new TypeError('Constructor Promise requires "new"');
        }
        if (this && this._promise) {
          throw new TypeError('Bad construction');
        }
        // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
        if (!ES.IsCallable(resolver)) {
          throw new TypeError('not a valid resolver');
        }
        var promise = emulateES6construct(this, PromiseShim, Promise$prototype, {
          _promise: {
            result: void 0,
            state: PROMISE_PENDING,
            // The first member of the "reactions" array is inlined here,
            // since most promises only have one reaction.
            // We've also exploded the 'reaction' object to inline the
            // "handler" and "capability" fields, since both fulfill and
            // reject reactions share the same capability.
            reactionLength: 0,
            fulfillReactionHandler0: void 0,
            rejectReactionHandler0: void 0,
            reactionCapability0: void 0
          }
        });
        var resolvingFunctions = createResolvingFunctions(promise);
        var reject = resolvingFunctions.reject;
        try {
          resolver(resolvingFunctions.resolve, reject);
        } catch (e) {
          reject(e);
        }
        return promise;
      };
      return PromiseShim;
    }());
    Promise$prototype = Promise.prototype;

    var _promiseAllResolver = function (index, values, capability, remaining) {
      var alreadyCalled = false;
      return function (x) {
        if (alreadyCalled) { return; }
        alreadyCalled = true;
        values[index] = x;
        if ((--remaining.count) === 0) {
          var resolve = capability.resolve;
          resolve(values); // call w/ this===undefined
        }
      };
    };

    var performPromiseAll = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var values = [];
      var remaining = { count: 1 };
      var next, nextValue;
      var index = 0;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        values[index] = void 0;
        var nextPromise = C.resolve(nextValue);
        var resolveElement = _promiseAllResolver(
          index,
          values,
          resultCapability,
          remaining
        );
        remaining.count += 1;
        optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);
        index += 1;
      }
      if ((--remaining.count) === 0) {
        var resolve = resultCapability.resolve;
        resolve(values); // call w/ this===undefined
      }
      return resultCapability.promise;
    };

    var performPromiseRace = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var next, nextValue, nextPromise;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            // NOTE: If iterable has no items, resulting promise will never
            // resolve; see:
            // https://github.com/domenic/promises-unwrapping/issues/75
            // https://bugs.ecmascript.org/show_bug.cgi?id=2515
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        nextPromise = C.resolve(nextValue);
        optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);
      }
      return resultCapability.promise;
    };

    defineProperties(Promise, {
      all: function all(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseAll(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      race: function race(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseRace(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      reject: function reject(reason) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        var capability = new PromiseCapability(C);
        var rejectFunc = capability.reject;
        rejectFunc(reason); // call with this===undefined
        return capability.promise;
      },

      resolve: function resolve(v) {
        // See https://esdiscuss.org/topic/fixing-promise-resolve for spec
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        if (ES.IsPromise(v)) {
          var constructor = v.constructor;
          if (constructor === C) {
            return v;
          }
        }
        var capability = new PromiseCapability(C);
        var resolveFunc = capability.resolve;
        resolveFunc(v); // call with this===undefined
        return capability.promise;
      }
    });

    defineProperties(Promise$prototype, {
      'catch': function (onRejected) {
        return this.then(null, onRejected);
      },

      then: function then(onFulfilled, onRejected) {
        var promise = this;
        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
        var C = ES.SpeciesConstructor(promise, Promise);
        var resultCapability;
        var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;
        if (returnValueIsIgnored && C === Promise) {
          resultCapability = PROMISE_FAKE_CAPABILITY;
        } else {
          resultCapability = new PromiseCapability(C);
        }
        // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)
        // Note that we've split the 'reaction' object into its two
        // components, "capabilities" and "handler"
        // "capabilities" is always equal to `resultCapability`
        var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;
        var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;
        var _promise = promise._promise;
        var value;
        if (_promise.state === PROMISE_PENDING) {
          if (_promise.reactionLength === 0) {
            _promise.fulfillReactionHandler0 = fulfillReactionHandler;
            _promise.rejectReactionHandler0 = rejectReactionHandler;
            _promise.reactionCapability0 = resultCapability;
          } else {
            var idx = 3 * (_promise.reactionLength - 1);
            _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;
            _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;
            _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;
          }
          _promise.reactionLength += 1;
        } else if (_promise.state === PROMISE_FULFILLED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            fulfillReactionHandler,
            resultCapability,
            value
          );
        } else if (_promise.state === PROMISE_REJECTED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            rejectReactionHandler,
            resultCapability,
            value
          );
        } else {
          throw new TypeError('unexpected Promise state');
        }
        return resultCapability.promise;
      }
    });
    // This helps the optimizer by ensuring that methods which take
    // capabilities aren't polymorphic.
    PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise);
    Promise$prototype$then = Promise$prototype.then;

    return Promise;
  }());

  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
  if (globals.Promise) {
    delete globals.Promise.accept;
    delete globals.Promise.defer;
    delete globals.Promise.prototype.chain;
  }

  if (typeof PromiseShim === 'function') {
    // export the Promise constructor.
    defineProperties(globals, { Promise: PromiseShim });
    // In Chrome 33 (and thereabouts) Promise is defined, but the
    // implementation is buggy in a number of ways.  Let's check subclassing
    // support to see if we have a buggy implementation.
    var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
      return S.resolve(42).then(function () {}) instanceof S;
    });
    var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () {
      return globals.Promise.reject(42).then(null, 5).then(null, noop);
    });
    var promiseRequiresObjectContext = throwsError(function () { return globals.Promise.call(3, noop); });
    // Promise.resolve() was errata'ed late in the ES6 process.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742
    //      https://code.google.com/p/v8/issues/detail?id=4161
    // It serves as a proxy for a number of other bugs in early Promise
    // implementations.
    var promiseResolveBroken = (function (Promise) {
      var p = Promise.resolve(5);
      p.constructor = {};
      var p2 = Promise.resolve(p);
      try {
        p2.then(null, noop).then(null, noop); // avoid "uncaught rejection" warnings in console
      } catch (e) {
        return true; // v8 native Promises break here https://code.google.com/p/chromium/issues/detail?id=575314
      }
      return p === p2; // This *should* be false!
    }(globals.Promise));

    // Chrome 46 (probably older too) does not retrieve a thenable's .then synchronously
    var getsThenSynchronously = supportsDescriptors && (function () {
      var count = 0;
      // eslint-disable-next-line getter-return
      var thenable = Object.defineProperty({}, 'then', { get: function () { count += 1; } });
      Promise.resolve(thenable);
      return count === 1;
    }());

    var BadResolverPromise = function BadResolverPromise(executor) {
      var p = new Promise(executor);
      executor(3, function () {});
      this.then = p.then;
      this.constructor = BadResolverPromise;
    };
    BadResolverPromise.prototype = Promise.prototype;
    BadResolverPromise.all = Promise.all;
    // Chrome Canary 49 (probably older too) has some implementation bugs
    var hasBadResolverPromise = valueOrFalseIfThrows(function () {
      return !!BadResolverPromise.all([1, 2]);
    });

    if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||
        !promiseRequiresObjectContext || promiseResolveBroken ||
        !getsThenSynchronously || hasBadResolverPromise) {
      /* globals Promise: true */
      /* eslint-disable no-undef, no-global-assign */
      Promise = PromiseShim;
      /* eslint-enable no-undef, no-global-assign */
      overrideNative(globals, 'Promise', PromiseShim);
    }
    if (Promise.all.length !== 1) {
      var origAll = Promise.all;
      overrideNative(Promise, 'all', function all(iterable) {
        return ES.Call(origAll, this, arguments);
      });
    }
    if (Promise.race.length !== 1) {
      var origRace = Promise.race;
      overrideNative(Promise, 'race', function race(iterable) {
        return ES.Call(origRace, this, arguments);
      });
    }
    if (Promise.resolve.length !== 1) {
      var origResolve = Promise.resolve;
      overrideNative(Promise, 'resolve', function resolve(x) {
        return ES.Call(origResolve, this, arguments);
      });
    }
    if (Promise.reject.length !== 1) {
      var origReject = Promise.reject;
      overrideNative(Promise, 'reject', function reject(r) {
        return ES.Call(origReject, this, arguments);
      });
    }
    ensureEnumerable(Promise, 'all');
    ensureEnumerable(Promise, 'race');
    ensureEnumerable(Promise, 'resolve');
    ensureEnumerable(Promise, 'reject');
    addDefaultSpecies(Promise);
  }

  // Map and Set require a true ES5 environment
  // Their fast path also requires that the environment preserve
  // property insertion order, which is not guaranteed by the spec.
  var testOrder = function (a) {
    var b = keys(_reduce(a, function (o, k) {
      o[k] = true;
      return o;
    }, {}));
    return a.join(':') === b.join(':');
  };
  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
  // some engines (eg, Chrome) only preserve insertion order for string keys
  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

  if (supportsDescriptors) {

    var fastkey = function fastkey(key, skipInsertionOrderCheck) {
      if (!skipInsertionOrderCheck && !preservesInsertionOrder) {
        return null;
      }
      if (isNullOrUndefined(key)) {
        return '^' + ES.ToString(key);
      } else if (typeof key === 'string') {
        return '$' + key;
      } else if (typeof key === 'number') {
        // note that -0 will get coerced to "0" when used as a property key
        if (!preservesNumericInsertionOrder) {
          return 'n' + key;
        }
        return key;
      } else if (typeof key === 'boolean') {
        return 'b' + key;
      }
      return null;
    };

    var emptyObject = function emptyObject() {
      // accomodate some older not-quite-ES5 browsers
      return Object.create ? Object.create(null) : {};
    };

    var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (entry) {
          if (!ES.TypeIsObject(entry)) {
            throw new TypeError('Iterator value ' + entry + ' is not an entry object');
          }
          map.set(entry[0], entry[1]);
        });
      } else if (iterable instanceof MapConstructor) {
        _call(MapConstructor.prototype.forEach, iterable, function (value, key) {
          map.set(key, value);
        });
      } else {
        var iter, adder;
        if (!isNullOrUndefined(iterable)) {
          adder = map.set;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextItem = next.value;
            try {
              if (!ES.TypeIsObject(nextItem)) {
                throw new TypeError('Iterator value ' + nextItem + ' is not an entry object');
              }
              _call(adder, map, nextItem[0], nextItem[1]);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };
    var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (value) {
          set.add(value);
        });
      } else if (iterable instanceof SetConstructor) {
        _call(SetConstructor.prototype.forEach, iterable, function (value) {
          set.add(value);
        });
      } else {
        var iter, adder;
        if (!isNullOrUndefined(iterable)) {
          adder = set.add;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextValue = next.value;
            try {
              _call(adder, set, nextValue);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };

    var collectionShims = {
      Map: (function () {

        var empty = {};

        var MapEntry = function MapEntry(key, value) {
          this.key = key;
          this.value = value;
          this.next = null;
          this.prev = null;
        };

        MapEntry.prototype.isRemoved = function isRemoved() {
          return this.key === empty;
        };

        var isMap = function isMap(map) {
          return !!map._es6map;
        };

        var requireMapSlot = function requireMapSlot(map, method) {
          if (!ES.TypeIsObject(map) || !isMap(map)) {
            throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(map));
          }
        };

        var MapIterator = function MapIterator(map, kind) {
          requireMapSlot(map, '[[MapIterator]]');
          this.head = map._head;
          this.i = this.head;
          this.kind = kind;
        };

        MapIterator.prototype = {
          isMapIterator: true,
          next: function next() {
            if (!this.isMapIterator) {
              throw new TypeError('Not a MapIterator');
            }
            var i = this.i;
            var kind = this.kind;
            var head = this.head;
            if (typeof this.i === 'undefined') {
              return iteratorResult();
            }
            while (i.isRemoved() && i !== head) {
              // back up off of removed entries
              i = i.prev;
            }
            // advance to next unreturned element.
            var result;
            while (i.next !== head) {
              i = i.next;
              if (!i.isRemoved()) {
                if (kind === 'key') {
                  result = i.key;
                } else if (kind === 'value') {
                  result = i.value;
                } else {
                  result = [i.key, i.value];
                }
                this.i = i;
                return iteratorResult(result);
              }
            }
            // once the iterator is done, it is done forever.
            this.i = void 0;
            return iteratorResult();
          }
        };
        addIterator(MapIterator.prototype);

        var Map$prototype;
        var MapShim = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          if (this && this._es6map) {
            throw new TypeError('Bad construction');
          }
          var map = emulateES6construct(this, Map, Map$prototype, {
            _es6map: true,
            _head: null,
            _map: OrigMap ? new OrigMap() : null,
            _size: 0,
            _storage: emptyObject()
          });

          var head = new MapEntry(null, null);
          // circular doubly-linked list.
          /* eslint no-multi-assign: 1 */
          head.next = head.prev = head;
          map._head = head;

          // Optionally initialize map from iterable
          if (arguments.length > 0) {
            addIterableToMap(Map, map, arguments[0]);
          }
          return map;
        };
        Map$prototype = MapShim.prototype;

        Value.getter(Map$prototype, 'size', function () {
          if (typeof this._size === 'undefined') {
            throw new TypeError('size method called on incompatible Map');
          }
          return this._size;
        });

        defineProperties(Map$prototype, {
          get: function get(key) {
            requireMapSlot(this, 'get');
            var entry;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              entry = this._storage[fkey];
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            if (this._map) {
              // fast object key path
              entry = origMapGet.call(this._map, key);
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return i.value;
              }
            }
          },

          has: function has(key) {
            requireMapSlot(this, 'has');
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              return typeof this._storage[fkey] !== 'undefined';
            }
            if (this._map) {
              // fast object key path
              return origMapHas.call(this._map, key);
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return true;
              }
            }
            return false;
          },

          set: function set(key, value) {
            requireMapSlot(this, 'set');
            var head = this._head;
            var i = head;
            var entry;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] !== 'undefined') {
                this._storage[fkey].value = value;
                return this;
              } else {
                entry = this._storage[fkey] = new MapEntry(key, value); /* eslint no-multi-assign: 1 */
                i = head.prev;
                // fall through
              }
            } else if (this._map) {
              // fast object key path
              if (origMapHas.call(this._map, key)) {
                origMapGet.call(this._map, key).value = value;
              } else {
                entry = new MapEntry(key, value);
                origMapSet.call(this._map, key, entry);
                i = head.prev;
                // fall through
              }
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.value = value;
                return this;
              }
            }
            entry = entry || new MapEntry(key, value);
            if (ES.SameValue(-0, key)) {
              entry.key = +0; // coerce -0 to +0 in entry
            }
            entry.next = this._head;
            entry.prev = this._head.prev;
            entry.prev.next = entry;
            entry.next.prev = entry;
            this._size += 1;
            return this;
          },

          'delete': function (key) {
            requireMapSlot(this, 'delete');
            var head = this._head;
            var i = head;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] === 'undefined') {
                return false;
              }
              i = this._storage[fkey].prev;
              delete this._storage[fkey];
              // fall through
            } else if (this._map) {
              // fast object key path
              if (!origMapHas.call(this._map, key)) {
                return false;
              }
              i = origMapGet.call(this._map, key).prev;
              origMapDelete.call(this._map, key);
              // fall through
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.key = empty;
                i.value = empty;
                i.prev.next = i.next;
                i.next.prev = i.prev;
                this._size -= 1;
                return true;
              }
            }
            return false;
          },

          clear: function clear() {
            /* eslint no-multi-assign: 1 */
            requireMapSlot(this, 'clear');
            this._map = OrigMap ? new OrigMap() : null;
            this._size = 0;
            this._storage = emptyObject();
            var head = this._head;
            var i = head;
            var p = i.next;
            while ((i = p) !== head) {
              i.key = empty;
              i.value = empty;
              p = i.next;
              i.next = i.prev = head;
            }
            head.next = head.prev = head;
          },

          keys: function keys() {
            requireMapSlot(this, 'keys');
            return new MapIterator(this, 'key');
          },

          values: function values() {
            requireMapSlot(this, 'values');
            return new MapIterator(this, 'value');
          },

          entries: function entries() {
            requireMapSlot(this, 'entries');
            return new MapIterator(this, 'key+value');
          },

          forEach: function forEach(callback) {
            requireMapSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var it = this.entries();
            for (var entry = it.next(); !entry.done; entry = it.next()) {
              if (context) {
                _call(callback, context, entry.value[1], entry.value[0], this);
              } else {
                callback(entry.value[1], entry.value[0], this);
              }
            }
          }
        });
        addIterator(Map$prototype, Map$prototype.entries);

        return MapShim;
      }()),

      Set: (function () {
        var isSet = function isSet(set) {
          return set._es6set && typeof set._storage !== 'undefined';
        };
        var requireSetSlot = function requireSetSlot(set, method) {
          if (!ES.TypeIsObject(set) || !isSet(set)) {
            // https://github.com/paulmillr/es6-shim/issues/176
            throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(set));
          }
        };

        // Creating a Map is expensive.  To speed up the common case of
        // Sets containing only string or numeric keys, we use an object
        // as backing storage and lazily create a full Map only when
        // required.
        var Set$prototype;
        var SetShim = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          if (this && this._es6set) {
            throw new TypeError('Bad construction');
          }
          var set = emulateES6construct(this, Set, Set$prototype, {
            _es6set: true,
            '[[SetData]]': null,
            _storage: emptyObject()
          });
          if (!set._es6set) {
            throw new TypeError('bad set');
          }

          // Optionally initialize Set from iterable
          if (arguments.length > 0) {
            addIterableToSet(Set, set, arguments[0]);
          }
          return set;
        };
        Set$prototype = SetShim.prototype;

        var decodeKey = function (key) {
          var k = key;
          if (k === '^null') {
            return null;
          } else if (k === '^undefined') {
            return void 0;
          } else {
            var first = k.charAt(0);
            if (first === '$') {
              return _strSlice(k, 1);
            } else if (first === 'n') {
              return +_strSlice(k, 1);
            } else if (first === 'b') {
              return k === 'btrue';
            }
          }
          return +k;
        };
        // Switch from the object backing storage to a full Map.
        var ensureMap = function ensureMap(set) {
          if (!set['[[SetData]]']) {
            var m = new collectionShims.Map();
            set['[[SetData]]'] = m;
            _forEach(keys(set._storage), function (key) {
              var k = decodeKey(key);
              m.set(k, k);
            });
            set['[[SetData]]'] = m;
          }
          set._storage = null; // free old backing storage
        };

        Value.getter(SetShim.prototype, 'size', function () {
          requireSetSlot(this, 'size');
          if (this._storage) {
            return keys(this._storage).length;
          }
          ensureMap(this);
          return this['[[SetData]]'].size;
        });

        defineProperties(SetShim.prototype, {
          has: function has(key) {
            requireSetSlot(this, 'has');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              return !!this._storage[fkey];
            }
            ensureMap(this);
            return this['[[SetData]]'].has(key);
          },

          add: function add(key) {
            requireSetSlot(this, 'add');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              this._storage[fkey] = true;
              return this;
            }
            ensureMap(this);
            this['[[SetData]]'].set(key, key);
            return this;
          },

          'delete': function (key) {
            requireSetSlot(this, 'delete');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              var hasFKey = _hasOwnProperty(this._storage, fkey);
              return (delete this._storage[fkey]) && hasFKey;
            }
            ensureMap(this);
            return this['[[SetData]]']['delete'](key);
          },

          clear: function clear() {
            requireSetSlot(this, 'clear');
            if (this._storage) {
              this._storage = emptyObject();
            }
            if (this['[[SetData]]']) {
              this['[[SetData]]'].clear();
            }
          },

          values: function values() {
            requireSetSlot(this, 'values');
            ensureMap(this);
            return new SetIterator(this['[[SetData]]'].values());
          },

          entries: function entries() {
            requireSetSlot(this, 'entries');
            ensureMap(this);
            return new SetIterator(this['[[SetData]]'].entries());
          },

          forEach: function forEach(callback) {
            requireSetSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var entireSet = this;
            ensureMap(entireSet);
            this['[[SetData]]'].forEach(function (value, key) {
              if (context) {
                _call(callback, context, key, key, entireSet);
              } else {
                callback(key, key, entireSet);
              }
            });
          }
        });
        defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);
        addIterator(SetShim.prototype, SetShim.prototype.values);

        var SetIterator = function SetIterator(it) {
          this.it = it;
        };
        SetIterator.prototype = {
          isSetIterator: true,
          next: function next() {
            if (!this.isSetIterator) {
              throw new TypeError('Not a SetIterator');
            }
            return this.it.next();
          }
        };
        addIterator(SetIterator.prototype);

        return SetShim;
      }())
    };

    var isGoogleTranslate = globals.Set && !Set.prototype['delete'] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray(new Set().keys);
    if (isGoogleTranslate) {
      // special-case force removal of wildly invalid Set implementation in Google Translate iframes
      // see https://github.com/paulmillr/es6-shim/issues/438 / https://twitter.com/ljharb/status/849335573114363904
      globals.Set = collectionShims.Set;
    }
    if (globals.Map || globals.Set) {
      // Safari 8, for example, doesn't accept an iterable.
      var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });
      if (!mapAcceptsArguments) {
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMap();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, globals.Map.prototype);
          return m;
        };
        globals.Map.prototype = create(OrigMap.prototype);
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMap);
      }
      var testMap = new Map();
      var mapUsesSameValueZero = (function () {
        // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4
        var m = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);
        m.set(-0, m);
        return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);
      }());
      var mapSupportsChaining = testMap.set(1, 2) === testMap;
      if (!mapUsesSameValueZero || !mapSupportsChaining) {
        overrideNative(Map.prototype, 'set', function set(k, v) {
          _call(origMapSet, this, k === 0 ? 0 : k, v);
          return this;
        });
      }
      if (!mapUsesSameValueZero) {
        defineProperties(Map.prototype, {
          get: function get(k) {
            return _call(origMapGet, this, k === 0 ? 0 : k);
          },
          has: function has(k) {
            return _call(origMapHas, this, k === 0 ? 0 : k);
          }
        }, true);
        Value.preserveToString(Map.prototype.get, origMapGet);
        Value.preserveToString(Map.prototype.has, origMapHas);
      }
      var testSet = new Set();
      var setUsesSameValueZero = Set.prototype['delete'] && Set.prototype.add && Set.prototype.has && (function (s) {
        s['delete'](0);
        s.add(-0);
        return !s.has(0);
      }(testSet));
      var setSupportsChaining = testSet.add(1) === testSet;
      if (!setUsesSameValueZero || !setSupportsChaining) {
        var origSetAdd = Set.prototype.add;
        Set.prototype.add = function add(v) {
          _call(origSetAdd, this, v === 0 ? 0 : v);
          return this;
        };
        Value.preserveToString(Set.prototype.add, origSetAdd);
      }
      if (!setUsesSameValueZero) {
        var origSetHas = Set.prototype.has;
        Set.prototype.has = function has(v) {
          return _call(origSetHas, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype.has, origSetHas);
        var origSetDel = Set.prototype['delete'];
        Set.prototype['delete'] = function SetDelete(v) {
          return _call(origSetDel, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype['delete'], origSetDel);
      }
      var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {
        var m = new M([]);
        // Firefox 32 is ok with the instantiating the subclass but will
        // throw when the map is used.
        m.set(42, 42);
        return m instanceof M;
      });
      // without Object.setPrototypeOf, subclassing is not possible
      var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing;
      var mapRequiresNew = (function () {
        try {
          return !(globals.Map() instanceof globals.Map);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMap();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, Map.prototype);
          return m;
        };
        globals.Map.prototype = OrigMap.prototype;
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMap);
      }
      var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {
        var s = new S([]);
        s.add(42, 42);
        return s instanceof S;
      });
      // without Object.setPrototypeOf, subclassing is not possible
      var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing;
      var setRequiresNew = (function () {
        try {
          return !(globals.Set() instanceof globals.Set);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
        var OrigSet = globals.Set;
        globals.Set = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          var s = new OrigSet();
          if (arguments.length > 0) {
            addIterableToSet(Set, s, arguments[0]);
          }
          delete s.constructor;
          Object.setPrototypeOf(s, Set.prototype);
          return s;
        };
        globals.Set.prototype = OrigSet.prototype;
        defineProperty(globals.Set.prototype, 'constructor', globals.Set, true);
        Value.preserveToString(globals.Set, OrigSet);
      }
      var newMap = new globals.Map();
      var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {
        return newMap.keys().next().done;
      });
      /*
        - In Firefox < 23, Map#size is a function.
        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
        - In Firefox 24, Map and Set do not implement forEach
        - In Firefox 25 at least, Map and Set are callable without "new"
      */
      if (
        typeof globals.Map.prototype.clear !== 'function' ||
        new globals.Set().size !== 0 ||
        newMap.size !== 0 ||
        typeof globals.Map.prototype.keys !== 'function' ||
        typeof globals.Set.prototype.keys !== 'function' ||
        typeof globals.Map.prototype.forEach !== 'function' ||
        typeof globals.Set.prototype.forEach !== 'function' ||
        isCallableWithoutNew(globals.Map) ||
        isCallableWithoutNew(globals.Set) ||
        typeof newMap.keys().next !== 'function' || // Safari 8
        mapIterationThrowsStopIterator || // Firefox 25
        !mapSupportsSubclassing
      ) {
        defineProperties(globals, {
          Map: collectionShims.Map,
          Set: collectionShims.Set
        }, true);
      }

      if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
        // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190
        defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
      }

      // Shim incomplete iterator implementations.
      addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
      addIterator(Object.getPrototypeOf((new globals.Set()).keys()));

      if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {
        // Microsoft Edge v0.11.10074.0 is missing a name on Set#has
        var anonymousSetHas = globals.Set.prototype.has;
        overrideNative(globals.Set.prototype, 'has', function has(key) {
          return _call(anonymousSetHas, this, key);
        });
      }
    }
    defineProperties(globals, collectionShims);
    addDefaultSpecies(globals.Map);
    addDefaultSpecies(globals.Set);
  }

  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
    if (!ES.TypeIsObject(target)) {
      throw new TypeError('target must be an object');
    }
  };

  // Some Reflect methods are basically the same as
  // those on the Object global, except that a TypeError is thrown if
  // target isn't an object. As well as returning a boolean indicating
  // the success of the operation.
  var ReflectShims = {
    // Apply method in a functional form.
    apply: function apply() {
      return ES.Call(ES.Call, null, arguments);
    },

    // New operator in a functional form.
    construct: function construct(constructor, args) {
      if (!ES.IsConstructor(constructor)) {
        throw new TypeError('First argument must be a constructor.');
      }
      var newTarget = arguments.length > 2 ? arguments[2] : constructor;
      if (!ES.IsConstructor(newTarget)) {
        throw new TypeError('new.target must be a constructor.');
      }
      return ES.Construct(constructor, args, newTarget, 'internal');
    },

    // When deleting a non-existent or configurable property,
    // true is returned.
    // When attempting to delete a non-configurable property,
    // it will return false.
    deleteProperty: function deleteProperty(target, key) {
      throwUnlessTargetIsObject(target);
      if (supportsDescriptors) {
        var desc = Object.getOwnPropertyDescriptor(target, key);

        if (desc && !desc.configurable) {
          return false;
        }
      }

      // Will return true.
      return delete target[key];
    },

    has: function has(target, key) {
      throwUnlessTargetIsObject(target);
      return key in target;
    }
  };

  if (Object.getOwnPropertyNames) {
    Object.assign(ReflectShims, {
      // Basically the result of calling the internal [[OwnPropertyKeys]].
      // Concatenating propertyNames and propertySymbols should do the trick.
      // This should continue to work together with a Symbol shim
      // which overrides Object.getOwnPropertyNames and implements
      // Object.getOwnPropertySymbols.
      ownKeys: function ownKeys(target) {
        throwUnlessTargetIsObject(target);
        var keys = Object.getOwnPropertyNames(target);

        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
          _pushApply(keys, Object.getOwnPropertySymbols(target));
        }

        return keys;
      }
    });
  }

  var callAndCatchException = function ConvertExceptionToBoolean(func) {
    return !throwsError(func);
  };

  if (Object.preventExtensions) {
    Object.assign(ReflectShims, {
      isExtensible: function isExtensible(target) {
        throwUnlessTargetIsObject(target);
        return Object.isExtensible(target);
      },
      preventExtensions: function preventExtensions(target) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          return Object.preventExtensions(target);
        });
      }
    });
  }

  if (supportsDescriptors) {
    var internalGet = function get(target, key, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent === null) {
          return void 0;
        }

        return internalGet(parent, key, receiver);
      }

      if ('value' in desc) {
        return desc.value;
      }

      if (desc.get) {
        return ES.Call(desc.get, receiver);
      }

      return void 0;
    };

    var internalSet = function set(target, key, value, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent !== null) {
          return internalSet(parent, key, value, receiver);
        }

        desc = {
          value: void 0,
          writable: true,
          enumerable: true,
          configurable: true
        };
      }

      if ('value' in desc) {
        if (!desc.writable) {
          return false;
        }

        if (!ES.TypeIsObject(receiver)) {
          return false;
        }

        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

        if (existingDesc) {
          return Reflect.defineProperty(receiver, key, {
            value: value
          });
        } else {
          return Reflect.defineProperty(receiver, key, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }

      if (desc.set) {
        _call(desc.set, receiver, value);
        return true;
      }

      return false;
    };

    Object.assign(ReflectShims, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          return Object.defineProperty(target, propertyKey, attributes);
        });
      },

      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        throwUnlessTargetIsObject(target);
        return Object.getOwnPropertyDescriptor(target, propertyKey);
      },

      // Syntax in a functional form.
      get: function get(target, key) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 2 ? arguments[2] : target;

        return internalGet(target, key, receiver);
      },

      set: function set(target, key, value) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 3 ? arguments[3] : target;

        return internalSet(target, key, value, receiver);
      }
    });
  }

  if (Object.getPrototypeOf) {
    var objectDotGetPrototypeOf = Object.getPrototypeOf;
    ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
      throwUnlessTargetIsObject(target);
      return objectDotGetPrototypeOf(target);
    };
  }

  if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
    var willCreateCircularPrototype = function (object, lastProto) {
      var proto = lastProto;
      while (proto) {
        if (object === proto) {
          return true;
        }
        proto = ReflectShims.getPrototypeOf(proto);
      }
      return false;
    };

    Object.assign(ReflectShims, {
      // Sets the prototype of the given object.
      // Returns true on success, otherwise false.
      setPrototypeOf: function setPrototypeOf(object, proto) {
        throwUnlessTargetIsObject(object);
        if (proto !== null && !ES.TypeIsObject(proto)) {
          throw new TypeError('proto must be an object or null');
        }

        // If they already are the same, we're done.
        if (proto === Reflect.getPrototypeOf(object)) {
          return true;
        }

        // Cannot alter prototype if object not extensible.
        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
          return false;
        }

        // Ensure that we do not create a circular prototype chain.
        if (willCreateCircularPrototype(object, proto)) {
          return false;
        }

        Object.setPrototypeOf(object, proto);

        return true;
      }
    });
  }
  var defineOrOverrideReflectProperty = function (key, shim) {
    if (!ES.IsCallable(globals.Reflect[key])) {
      defineProperty(globals.Reflect, key, shim);
    } else {
      var acceptsPrimitives = valueOrFalseIfThrows(function () {
        globals.Reflect[key](1);
        globals.Reflect[key](NaN);
        globals.Reflect[key](true);
        return true;
      });
      if (acceptsPrimitives) {
        overrideNative(globals.Reflect, key, shim);
      }
    }
  };
  Object.keys(ReflectShims).forEach(function (key) {
    defineOrOverrideReflectProperty(key, ReflectShims[key]);
  });
  var originalReflectGetProto = globals.Reflect.getPrototypeOf;
  if (functionsHaveNames && originalReflectGetProto && originalReflectGetProto.name !== 'getPrototypeOf') {
    overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {
      return _call(originalReflectGetProto, globals.Reflect, target);
    });
  }
  if (globals.Reflect.setPrototypeOf) {
    if (valueOrFalseIfThrows(function () {
      globals.Reflect.setPrototypeOf(1, {});
      return true;
    })) {
      overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);
    }
  }
  if (globals.Reflect.defineProperty) {
    if (!valueOrFalseIfThrows(function () {
      var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });
      // "extensible" fails on Edge 0.12
      var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});
      return basic && extensible;
    })) {
      overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);
    }
  }
  if (globals.Reflect.construct) {
    if (!valueOrFalseIfThrows(function () {
      var F = function F() {};
      return globals.Reflect.construct(function () {}, [], F) instanceof F;
    })) {
      overrideNative(globals.Reflect, 'construct', ReflectShims.construct);
    }
  }

  if (String(new Date(NaN)) !== 'Invalid Date') {
    var dateToString = Date.prototype.toString;
    var shimmedDateToString = function toString() {
      var valueOf = +this;
      if (valueOf !== valueOf) {
        return 'Invalid Date';
      }
      return ES.Call(dateToString, this);
    };
    overrideNative(Date.prototype, 'toString', shimmedDateToString);
  }

  // Annex B HTML methods
  // http://www.ecma-international.org/ecma-262/6.0/#sec-additional-properties-of-the-string.prototype-object
  var stringHTMLshims = {
    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
  };
  _forEach(Object.keys(stringHTMLshims), function (key) {
    var method = String.prototype[key];
    var shouldOverwrite = false;
    if (ES.IsCallable(method)) {
      var output = _call(method, '', ' " ');
      var quotesCount = _concat([], output.match(/"/g)).length;
      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
    } else {
      shouldOverwrite = true;
    }
    if (shouldOverwrite) {
      overrideNative(String.prototype, key, stringHTMLshims[key]);
    }
  });

  var JSONstringifiesSymbols = (function () {
    // Microsoft Edge v0.12 stringifies Symbols incorrectly
    if (!hasSymbols) { return false; } // Symbols are not supported
    var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;
    if (!stringify) { return false; } // JSON.stringify is not supported
    if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`
    if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`
    var obj = { a: Symbol() };
    obj[Symbol()] = true;
    if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted
    return false;
  }());
  var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {
    // Chrome 45 throws on stringifying object symbols
    if (!hasSymbols) { return true; } // Symbols are not supported
    return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';
  });
  if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
    var origStringify = JSON.stringify;
    overrideNative(JSON, 'stringify', function stringify(value) {
      if (typeof value === 'symbol') { return; }
      var replacer;
      if (arguments.length > 1) {
        replacer = arguments[1];
      }
      var args = [value];
      if (!isArray(replacer)) {
        var replaceFn = ES.IsCallable(replacer) ? replacer : null;
        var wrappedReplacer = function (key, val) {
          var parsedValue = replaceFn ? _call(replaceFn, this, key, val) : val;
          if (typeof parsedValue !== 'symbol') {
            if (Type.symbol(parsedValue)) {
              return assignTo({})(parsedValue);
            } else {
              return parsedValue;
            }
          }
        };
        args.push(wrappedReplacer);
      } else {
        // create wrapped replacer that handles an array replacer?
        args.push(replacer);
      }
      if (arguments.length > 2) {
        args.push(arguments[2]);
      }
      return origStringify.apply(this, args);
    });
  }

  return globals;
}));</script>
<script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var proto = require('./Array.prototype');

module.exports = {
	prototype: proto,
	shim: function shimArray() {
		proto.shim();
	}
};

},{"./Array.prototype":3}],2:[function(require,module,exports){
'use strict';

module.exports = require('array-includes');

},{"array-includes":14}],3:[function(require,module,exports){
'use strict';

var includes = require('./Array.prototype.includes');

module.exports = {
	includes: includes,
	shim: function shimArrayPrototype() {
		includes.shim();
	}
};

},{"./Array.prototype.includes":2}],4:[function(require,module,exports){
'use strict';

var getDescriptors = require('object.getownpropertydescriptors');
var entries = require('object.entries');
var values = require('object.values');

module.exports = {
	entries: entries,
	getOwnPropertyDescriptors: getDescriptors,
	shim: function shimObject() {
		getDescriptors.shim();
		entries.shim();
		values.shim();
	},
	values: values
};

},{"object.entries":38,"object.getownpropertydescriptors":64,"object.values":89}],5:[function(require,module,exports){
'use strict';

var stringPrototype = require('./String.prototype');

module.exports = {
	prototype: stringPrototype,
	shim: function shimString() {
		stringPrototype.shim();
	}
};

},{"./String.prototype":7}],6:[function(require,module,exports){
'use strict';

module.exports = require('string-at');

},{"string-at":114}],7:[function(require,module,exports){
'use strict';

var at = require('./String.prototype.at');
var padStart = require('./String.prototype.padStart');
var padEnd = require('./String.prototype.padEnd');
var trimLeft = require('./String.prototype.trimLeft');
var trimRight = require('./String.prototype.trimRight');

module.exports = {
	at: at,
	padStart: padStart,
	padEnd: padEnd,
	trimLeft: trimLeft,
	trimRight: trimRight,
	shim: function shimStringPrototype() {
		at.shim();
		padStart.shim();
		padEnd.shim();
		trimLeft.shim();
		trimRight.shim();
	}
};

},{"./String.prototype.at":6,"./String.prototype.padEnd":8,"./String.prototype.padStart":9,"./String.prototype.trimLeft":10,"./String.prototype.trimRight":11}],8:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.padend');

},{"string.prototype.padend":137}],9:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.padstart');

},{"string.prototype.padstart":162}],10:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.trimleft');

},{"string.prototype.trimleft":187}],11:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.trimright');

},{"string.prototype.trimright":197}],12:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es7-shim
 * @license es7-shim Copyright 2014 by contributors, MIT License
 * see https://github.com/es-shims/es7-shim/blob/master/LICENSE
 */

'use strict';

var $Array = require('./Array');
var $Object = require('./Object');
var $String = require('./String');

module.exports = {
	Array: $Array,
	Object: $Object,
	String: $String,
	shim: function shimES7() {
		$Array.shim();
		$Object.shim();
		$String.shim();
	}
};

},{"./Array":1,"./Object":4,"./String":5}],13:[function(require,module,exports){
(function (global){
'use strict';

var ES = require('es-abstract/es6');
var $isNaN = Number.isNaN || function (a) { return a !== a; };
var $isFinite = Number.isFinite || function (n) { return typeof n === 'number' && global.isFinite(n); };
var indexOf = Array.prototype.indexOf;

module.exports = function includes(searchElement) {
	var fromIndex = arguments.length > 1 ? ES.ToInteger(arguments[1]) : 0;
	if (indexOf && !$isNaN(searchElement) && $isFinite(fromIndex) && typeof searchElement !== 'undefined') {
		return indexOf.apply(this, arguments) > -1;
	}

	var O = ES.ToObject(this);
	var length = ES.ToLength(O.length);
	if (length === 0) {
		return false;
	}
	var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);
	while (k < length) {
		if (ES.SameValueZero(searchElement, O[k])) {
			return true;
		}
		k += 1;
	}
	return false;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"es-abstract/es6":17}],14:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var ES = require('es-abstract/es6');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var polyfill = getPolyfill();
var shim = require('./shim');

var slice = Array.prototype.slice;

/* eslint-disable no-unused-vars */
var boundIncludesShim = function includes(array, searchElement) {
/* eslint-enable no-unused-vars */
	ES.RequireObjectCoercible(array);
	return polyfill.apply(array, slice.call(arguments, 1));
};
define(boundIncludesShim, {
	implementation: implementation,
	getPolyfill: getPolyfill,
	shim: shim
});

module.exports = boundIncludesShim;

},{"./implementation":13,"./polyfill":35,"./shim":36,"define-properties":15,"es-abstract/es6":17}],15:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var foreach = require('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":26,"object-keys":33}],16:[function(require,module,exports){
'use strict';

var $isNaN = Number.isNaN || function (a) { return a !== a; };
var $isFinite = require('./helpers/isFinite');

var sign = require('./helpers/sign');
var mod = require('./helpers/mod');

var IsCallable = require('is-callable');
var toPrimitive = require('es-to-primitive/es5');

// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: toPrimitive,

	ToBoolean: function ToBoolean(value) {
		return Boolean(value);
	},
	ToNumber: function ToNumber(value) {
		return Number(value);
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number)) { return 0; }
		if (number === 0 || !$isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new TypeError(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: IsCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
        return $isNaN(x) && $isNaN(y);
	}
};

module.exports = ES5;

},{"./helpers/isFinite":19,"./helpers/mod":21,"./helpers/sign":22,"es-to-primitive/es5":23,"is-callable":29}],17:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;

var $isNaN = Number.isNaN || function (a) { return a !== a; };
var $isFinite = require('./helpers/isFinite');
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var assign = require('./helpers/assign');
var sign = require('./helpers/sign');
var mod = require('./helpers/mod');
var isPrimitive = require('./helpers/isPrimitive');
var toPrimitive = require('es-to-primitive/es6');
var parseInteger = parseInt;
var bind = require('function-bind');
var strSlice = bind.call(Function.call, String.prototype.slice);
var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
var invalidHexLiteral = /^[\-\+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);

// whitespace from: http://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var replace = bind.call(Function.call, String.prototype.replace);
var trim = function (value) {
	return replace(value, trimRegex, '');
};

var ES5 = require('./es5');

var hasRegExpMatcher = require('is-regex');

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
var ES6 = assign(assign({}, ES5), {

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	Call: function Call(F, V) {
		var args = arguments.length > 2 ? arguments[2] : [];
		if (!this.IsCallable(F)) {
			throw new TypeError(F + ' is not a function');
		}
		return F.apply(V, args);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
	ToPrimitive: toPrimitive,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
	// ToBoolean: ES5.ToBoolean,

	// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
	ToNumber: function ToNumber(argument) {
		var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
		if (typeof value === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a number');
		}
		if (typeof value === 'string') {
			if (isBinary(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 2));
			} else if (isOctal(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 8));
			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
				return NaN;
			} else {
				var trimmed = trim(value);
				if (trimmed !== value) {
					return this.ToNumber(trimmed);
				}
			}
		}
		return Number(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
	// ToInteger: ES5.ToNumber,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
	// ToInt32: ES5.ToInt32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
	// ToUint32: ES5.ToUint32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
	ToInt16: function ToInt16(argument) {
		var int16bit = this.ToUint16(argument);
		return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
	// ToUint16: ES5.ToUint16,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
	ToInt8: function ToInt8(argument) {
		var int8bit = this.ToUint8(argument);
		return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
	ToUint8: function ToUint8(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x100);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
	ToUint8Clamp: function ToUint8Clamp(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number <= 0) { return 0; }
		if (number >= 0xFF) { return 0xFF; }
		var f = Math.floor(argument);
		if (f + 0.5 < number) { return f + 1; }
		if (number < f + 0.5) { return f; }
		if (f % 2 !== 0) { return f + 1; }
		return f;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
	ToString: function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a string');
		}
		return String(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
	ToObject: function ToObject(value) {
		this.RequireObjectCoercible(value);
		return Object(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
	ToPropertyKey: function ToPropertyKey(argument) {
		var key = this.ToPrimitive(argument, String);
		return typeof key === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	ToLength: function ToLength(argument) {
		var len = this.ToInteger(argument);
		if (len <= 0) { return 0; } // includes converting -0 to +0
		if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
		return len;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-canonicalnumericindexstring
	CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
		if (toStr.call(argument) !== '[object String]') {
			throw new TypeError('must be a string');
		}
		if (argument === '-0') { return -0; }
		var n = this.ToNumber(argument);
		if (this.SameValue(this.ToString(n), argument)) { return n; }
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
	RequireObjectCoercible: ES5.CheckObjectCoercible,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
	IsArray: Array.isArray || function IsArray(argument) {
		return toStr.call(argument) === '[object Array]';
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
	// IsCallable: ES5.IsCallable,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
	IsConstructor: function IsConstructor(argument) {
		return this.IsCallable(argument); // unfortunately there's no way to truly check this without try/catch `new argument`
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
	IsExtensible: function IsExtensible(obj) {
		if (!Object.preventExtensions) { return true; }
		if (isPrimitive(obj)) {
			return false;
		}
		return Object.isExtensible(obj);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
	IsInteger: function IsInteger(argument) {
		if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
			return false;
		}
		var abs = Math.abs(argument);
		return Math.floor(abs) === abs;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
	IsPropertyKey: function IsPropertyKey(argument) {
		return typeof argument === 'string' || typeof argument === 'symbol';
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
	IsRegExp: function IsRegExp(argument) {
		if (!argument || typeof argument !== 'object') {
			return false;
		}
		if (hasSymbols) {
			var isRegExp = RegExp[Symbol.match];
			if (typeof isRegExp !== 'undefined') {
				return ES5.ToBoolean(isRegExp);
			}
		}
		return hasRegExpMatcher(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
	// SameValue: ES5.SameValue,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
	SameValueZero: function SameValueZero(x, y) {
		return (x === y) || ($isNaN(x) && $isNaN(y));
	}
});

delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

module.exports = ES6;

},{"./es5":16,"./helpers/assign":18,"./helpers/isFinite":19,"./helpers/isPrimitive":20,"./helpers/mod":21,"./helpers/sign":22,"es-to-primitive/es6":24,"function-bind":28,"is-regex":31}],18:[function(require,module,exports){
var has = Object.prototype.hasOwnProperty;
module.exports = Object.assign || function assign(target, source) {
	for (var key in source) {
		if (has.call(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
};

},{}],19:[function(require,module,exports){
var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

},{}],20:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],21:[function(require,module,exports){
module.exports = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};

},{}],22:[function(require,module,exports){
module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};

},{}],23:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable');

// https://es5.github.io/#x8.12
var ES5internalSlots = {
	'[[DefaultValue]]': function (O, hint) {
		var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// https://es5.github.io/#x9
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
};

},{"./helpers/isPrimitive":25,"is-callable":29}],24:[function(require,module,exports){
'use strict';

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');
var isCallable = require('is-callable');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (PreferredType === String) {
			hint = 'string';
		} else if (PreferredType === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"./helpers/isPrimitive":25,"is-callable":29,"is-date-object":30,"is-symbol":32}],25:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],26:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],27:[function(require,module,exports){
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],28:[function(require,module,exports){
var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":27}],29:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFn(value) {
	try {
		var fnStr = fnToStr.call(value);
		var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
		var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
		var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
		return constructorRegex.test(spaceStripped);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionObject(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],30:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],31:[function(require,module,exports){
'use strict';

var regexExec = RegExp.prototype.exec;
var tryRegexExec = function tryRegexExec(value) {
	try {
		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;
};

},{}],32:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') { return false; }
		return symStringRegex.test(symToStr.call(value));
	};
	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') { return true; }
		if (toStr.call(value) !== '[object Symbol]') { return false; }
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {
	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false;
	};
}

},{}],33:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var blacklistedKeys = {
	$console: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$parent: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!blacklistedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":34}],34:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],35:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return Array.prototype.includes || implementation;
};

},{"./implementation":13}],36:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimArrayPrototypeIncludes() {
	var polyfill = getPolyfill();
	if (Array.prototype.includes !== polyfill) {
		define(Array.prototype, { includes: polyfill });
	}
	return polyfill;
};

},{"./polyfill":35,"define-properties":15}],37:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');
var has = require('has');
var bind = require('function-bind');
var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function entries(O) {
	var obj = ES.RequireObjectCoercible(O);
	var entrys = [];
	for (var key in obj) {
		if (has(obj, key) && isEnumerable(obj, key)) {
			entrys.push([key, obj[key]]);
		}
	}
	return entrys;
};

},{"es-abstract/es7":42,"function-bind":53,"has":54}],38:[function(require,module,exports){
'use strict';

var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

define(implementation, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = implementation;

},{"./implementation":37,"./polyfill":61,"./shim":62,"define-properties":39}],39:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":51,"object-keys":59}],40:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":44,"./helpers/mod":46,"./helpers/sign":47,"dup":16,"es-to-primitive/es5":48,"is-callable":55}],41:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":40,"./helpers/assign":43,"./helpers/isFinite":44,"./helpers/isPrimitive":45,"./helpers/mod":46,"./helpers/sign":47,"dup":17,"es-to-primitive/es6":49,"function-bind":53,"is-regex":57}],42:[function(require,module,exports){
'use strict';

var ES6 = require('./es6');
var assign = require('./helpers/assign');

var ES7 = assign(ES6, {
	// https://github.com/tc39/ecma262/pull/60
	SameValueNonNumber: function SameValueNonNumber(x, y) {
		if (typeof x === 'number' || typeof x !== typeof y) {
			throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
		}
		return this.SameValue(x, y);
	}
});

module.exports = ES7;

},{"./es6":41,"./helpers/assign":43}],43:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],44:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],45:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],46:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],47:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],48:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":50,"dup":23,"is-callable":55}],49:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":50,"dup":24,"is-callable":55,"is-date-object":56,"is-symbol":58}],50:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],51:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],52:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],53:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":52,"dup":28}],54:[function(require,module,exports){
var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":53}],55:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],56:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],57:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],58:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],59:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":60,"dup":33}],60:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],61:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.entries === 'function' ? Object.entries : implementation;
};

},{"./implementation":37}],62:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimEntries() {
	var polyfill = getPolyfill();
	define(Object, { entries: polyfill }, { entries: function () { return Object.entries !== polyfill; } });
	return polyfill;
};

},{"./polyfill":61,"define-properties":39}],63:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');

var defineProperty = Object.defineProperty;
var getDescriptor = Object.getOwnPropertyDescriptor;
var getOwnNames = Object.getOwnPropertyNames;
var getSymbols = Object.getOwnPropertySymbols;
var concat = Function.call.bind(Array.prototype.concat);
var reduce = Function.call.bind(Array.prototype.reduce);
var getAll = getSymbols ? function (obj) {
	return concat(getOwnNames(obj), getSymbols(obj));
} : getOwnNames;

var isES5 = ES.IsCallable(getDescriptor) && ES.IsCallable(getOwnNames);

var safePut = function put(obj, prop, val) {
	if (defineProperty && prop in obj) {
		defineProperty(obj, prop, {
			configurable: true,
			enumerable: true,
			value: val,
			writable: true
		});
	} else {
		obj[prop] = val;
	}
};

module.exports = function getOwnPropertyDescriptors(value) {
	ES.RequireObjectCoercible(value);
	if (!isES5) { throw new TypeError('getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor'); }

	var O = ES.ToObject(value);
	return reduce(getAll(O), function (acc, key) {
		safePut(acc, key, getDescriptor(O, key));
		return acc;
	}, {});
};

},{"es-abstract/es7":68}],64:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./implementation":63,"./polyfill":86,"./shim":87,"define-properties":65,"dup":38}],65:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":77,"object-keys":84}],66:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":70,"./helpers/mod":72,"./helpers/sign":73,"dup":16,"es-to-primitive/es5":74,"is-callable":80}],67:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":66,"./helpers/assign":69,"./helpers/isFinite":70,"./helpers/isPrimitive":71,"./helpers/mod":72,"./helpers/sign":73,"dup":17,"es-to-primitive/es6":75,"function-bind":79,"is-regex":82}],68:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":67,"./helpers/assign":69,"dup":42}],69:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],70:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],71:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],72:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],73:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],74:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":76,"dup":23,"is-callable":80}],75:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":76,"dup":24,"is-callable":80,"is-date-object":81,"is-symbol":83}],76:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],77:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],78:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],79:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":78,"dup":28}],80:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],81:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],82:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],83:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],84:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":85,"dup":33}],85:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],86:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.getOwnPropertyDescriptors === 'function' ? Object.getOwnPropertyDescriptors : implementation;
};

},{"./implementation":63}],87:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimGetOwnPropertyDescriptors() {
	var polyfill = getPolyfill();
	define(Object, { getOwnPropertyDescriptors: polyfill }, {
		getOwnPropertyDescriptors: function () { return Object.getOwnPropertyDescriptors !== polyfill; }
	});
	return polyfill;
};

},{"./polyfill":86,"define-properties":65}],88:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');
var has = require('has');
var bind = require('function-bind');
var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function values(O) {
	var obj = ES.RequireObjectCoercible(O);
	var vals = [];
	for (var key in obj) {
		if (has(obj, key) && isEnumerable(obj, key)) {
			vals.push(obj[key]);
		}
	}
	return vals;
};

},{"es-abstract/es7":93,"function-bind":104,"has":105}],89:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./implementation":88,"./polyfill":112,"./shim":113,"define-properties":90,"dup":38}],90:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":102,"object-keys":110}],91:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":95,"./helpers/mod":97,"./helpers/sign":98,"dup":16,"es-to-primitive/es5":99,"is-callable":106}],92:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":91,"./helpers/assign":94,"./helpers/isFinite":95,"./helpers/isPrimitive":96,"./helpers/mod":97,"./helpers/sign":98,"dup":17,"es-to-primitive/es6":100,"function-bind":104,"is-regex":108}],93:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":92,"./helpers/assign":94,"dup":42}],94:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],95:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],96:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],97:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],98:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],99:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":101,"dup":23,"is-callable":106}],100:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":101,"dup":24,"is-callable":106,"is-date-object":107,"is-symbol":109}],101:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],102:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],103:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],104:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":103,"dup":28}],105:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54,"function-bind":104}],106:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],107:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],108:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],109:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],110:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":111,"dup":33}],111:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],112:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.values === 'function' ? Object.values : implementation;
};

},{"./implementation":88}],113:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimValues() {
	var polyfill = getPolyfill();
	define(Object, { values: polyfill }, { values: function () { return Object.values !== polyfill; } });
	return polyfill;
};

},{"./polyfill":112,"define-properties":90}],114:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var ES = require('es-abstract/es7');
var bind = require('function-bind');

var atShim = function at(pos) {
	ES.RequireObjectCoercible(this);
	var O = ES.ToObject(this);
	var S = ES.ToString(O);
	var position = ES.ToInteger(pos);
	var size = S.length;
	if (position < 0 || position >= size) {
		return '';
	}
	// Get the first code unit and code unit value
	var cuFirst = S.charCodeAt(position);
	var cuSecond;
	var nextIndex = position + 1;
	var len = 1;
	// Check if itâ€™s the start of a surrogate pair.
	var isHighSurrogate = cuFirst >= 0xD800 && cuFirst <= 0xDBFF;
	if (isHighSurrogate && size > nextIndex /* there is a next code unit */) {
		cuSecond = S.charCodeAt(nextIndex);
		if (cuSecond >= 0xDC00 && cuSecond <= 0xDFFF) { // low surrogate
			len = 2;
		}
	}
	return S.slice(position, position + len);
};

var at = bind.call(Function.call, atShim);
define(at, {
	method: atShim,
	shim: function shimStringPrototypeAt() {
		define(String.prototype, {
			at: atShim
		});
		return String.prototype.at;
	}
});

module.exports = at;

},{"define-properties":115,"es-abstract/es7":118,"function-bind":129}],115:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":127,"object-keys":134}],116:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":120,"./helpers/mod":122,"./helpers/sign":123,"dup":16,"es-to-primitive/es5":124,"is-callable":130}],117:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":116,"./helpers/assign":119,"./helpers/isFinite":120,"./helpers/isPrimitive":121,"./helpers/mod":122,"./helpers/sign":123,"dup":17,"es-to-primitive/es6":125,"function-bind":129,"is-regex":132}],118:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":117,"./helpers/assign":119,"dup":42}],119:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],120:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],121:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],122:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],123:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],124:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":126,"dup":23,"is-callable":130}],125:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":126,"dup":24,"is-callable":130,"is-date-object":131,"is-symbol":133}],126:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],127:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],128:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],129:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":128,"dup":28}],130:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],131:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],132:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],133:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],134:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":135,"dup":33}],135:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],136:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var ES = require('es-abstract/es7');
var slice = bind.call(Function.call, String.prototype.slice);

module.exports = function padEnd(maxLength) {
	var O = ES.RequireObjectCoercible(this);
	var S = ES.ToString(O);
	var stringLength = ES.ToLength(S.length);
	var fillString;
	if (arguments.length > 1) {
		fillString = arguments[1];
	}
	var filler = typeof fillString === 'undefined' ? '' : ES.ToString(fillString);
	if (filler === '') {
		filler = ' ';
	}
	var intMaxLength = ES.ToLength(maxLength);
	if (intMaxLength <= stringLength) {
		return S;
	}
	var fillLen = intMaxLength - stringLength;
	while (filler.length < fillLen) {
		var fLen = filler.length;
		var remainingCodeUnits = fillLen - fLen;
		filler += fLen > remainingCodeUnits ? slice(filler, 0, remainingCodeUnits) : filler;
	}

	var truncatedStringFiller = filler.length > fillLen ? slice(filler, 0, fillLen) : filler;
	return S + truncatedStringFiller;
};

},{"es-abstract/es7":141,"function-bind":152}],137:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');
var ES = require('es-abstract/es7');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var bound = bind.call(Function.apply, implementation);

var boundPadEnd = function padEnd(str, maxLength) {
	ES.RequireObjectCoercible(str);
	var args = [maxLength];
	if (arguments.length > 2) {
		args.push(arguments[2]);
	}
	return bound(str, args);
};

define(boundPadEnd, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundPadEnd;

},{"./implementation":136,"./polyfill":159,"./shim":160,"define-properties":138,"es-abstract/es7":141,"function-bind":152}],138:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":150,"object-keys":157}],139:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":143,"./helpers/mod":145,"./helpers/sign":146,"dup":16,"es-to-primitive/es5":147,"is-callable":153}],140:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":139,"./helpers/assign":142,"./helpers/isFinite":143,"./helpers/isPrimitive":144,"./helpers/mod":145,"./helpers/sign":146,"dup":17,"es-to-primitive/es6":148,"function-bind":152,"is-regex":155}],141:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":140,"./helpers/assign":142,"dup":42}],142:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],143:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],144:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],145:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],146:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],147:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":149,"dup":23,"is-callable":153}],148:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":149,"dup":24,"is-callable":153,"is-date-object":154,"is-symbol":156}],149:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],150:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],151:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],152:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":151,"dup":28}],153:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],154:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],155:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],156:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],157:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":158,"dup":33}],158:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],159:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof String.prototype.padEnd === 'function' ? String.prototype.padEnd : implementation;
};

},{"./implementation":136}],160:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimPadEnd() {
	var polyfill = getPolyfill();
	define(String.prototype, { padEnd: polyfill }, { padEnd: function () { return String.prototype.padEnd !== polyfill; } });
	return polyfill;
};

},{"./polyfill":159,"define-properties":138}],161:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var ES = require('es-abstract/es7');
var slice = bind.call(Function.call, String.prototype.slice);

module.exports = function padStart(maxLength) {
	var O = ES.RequireObjectCoercible(this);
	var S = ES.ToString(O);
	var stringLength = ES.ToLength(S.length);
	var fillString;
	if (arguments.length > 1) {
		fillString = arguments[1];
	}
	var filler = typeof fillString === 'undefined' ? '' : ES.ToString(fillString);
	if (filler === '') {
		filler = ' ';
	}
	var intMaxLength = ES.ToLength(maxLength);
	if (intMaxLength <= stringLength) {
		return S;
	}
	var fillLen = intMaxLength - stringLength;
	while (filler.length < fillLen) {
		var fLen = filler.length;
		var remainingCodeUnits = fillLen - fLen;
		filler += fLen > remainingCodeUnits ? slice(filler, 0, remainingCodeUnits) : filler;
	}

	var truncatedStringFiller = filler.length > fillLen ? slice(filler, 0, fillLen) : filler;
	return truncatedStringFiller + S;
};

},{"es-abstract/es7":166,"function-bind":177}],162:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');
var ES = require('es-abstract/es7');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var bound = bind.call(Function.apply, implementation);

var boundPadStart = function padStart(str, maxLength) {
	ES.RequireObjectCoercible(str);
	var args = [maxLength];
	if (arguments.length > 2) {
		args.push(arguments[2]);
	}
	return bound(str, args);
};

define(boundPadStart, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundPadStart;

},{"./implementation":161,"./polyfill":184,"./shim":185,"define-properties":163,"es-abstract/es7":166,"function-bind":177}],163:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":175,"object-keys":182}],164:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":168,"./helpers/mod":170,"./helpers/sign":171,"dup":16,"es-to-primitive/es5":172,"is-callable":178}],165:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":164,"./helpers/assign":167,"./helpers/isFinite":168,"./helpers/isPrimitive":169,"./helpers/mod":170,"./helpers/sign":171,"dup":17,"es-to-primitive/es6":173,"function-bind":177,"is-regex":180}],166:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":165,"./helpers/assign":167,"dup":42}],167:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],168:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],169:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],170:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],171:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],172:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":174,"dup":23,"is-callable":178}],173:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":174,"dup":24,"is-callable":178,"is-date-object":179,"is-symbol":181}],174:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],175:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],176:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],177:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":176,"dup":28}],178:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],179:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],180:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],181:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],182:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":183,"dup":33}],183:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],184:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof String.prototype.padStart === 'function' ? String.prototype.padStart : implementation;
};

},{"./implementation":161}],185:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimPadStart() {
	var polyfill = getPolyfill();
	define(String.prototype, { padStart: polyfill }, { padStart: function () { return String.prototype.padStart !== polyfill; } });
	return polyfill;
};

},{"./polyfill":184,"define-properties":163}],186:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var replace = bind.call(Function.call, String.prototype.replace);

var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;

module.exports = function trimLeft() {
	return replace(this, leftWhitespace, '');
};

},{"function-bind":191}],187:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var bound = bind.call(Function.call, getPolyfill());

define(bound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = bound;

},{"./implementation":186,"./polyfill":194,"./shim":195,"define-properties":188,"function-bind":191}],188:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":189,"object-keys":192}],189:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],190:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],191:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":190,"dup":28}],192:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":193,"dup":33}],193:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],194:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	if (!String.prototype.trimLeft) {
		return implementation;
	}
	var zeroWidthSpace = '\u200b';
	if (zeroWidthSpace.trimLeft() !== zeroWidthSpace) {
		return implementation;
	}
	return String.prototype.trimLeft;
};

},{"./implementation":186}],195:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimTrimLeft() {
	var polyfill = getPolyfill();
	define(
		String.prototype,
		{ trimLeft: polyfill },
		{ trimLeft: function () { return String.prototype.trimLeft !== polyfill; } }
	);
	return polyfill;
};

},{"./polyfill":194,"define-properties":188}],196:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var replace = bind.call(Function.call, String.prototype.replace);

var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;

module.exports = function trimRight() {
	return replace(this, rightWhitespace, '');
};

},{"function-bind":201}],197:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./implementation":196,"./polyfill":204,"./shim":205,"define-properties":198,"dup":187,"function-bind":201}],198:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":199,"object-keys":202}],199:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],200:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],201:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":200,"dup":28}],202:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":203,"dup":33}],203:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],204:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	if (!String.prototype.trimRight) {
		return implementation;
	}
	var zeroWidthSpace = '\u200b';
	if (zeroWidthSpace.trimRight() !== zeroWidthSpace) {
		return implementation;
	}
	return String.prototype.trimRight;
};

},{"./implementation":196}],205:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimTrimRight() {
	var polyfill = getPolyfill();
	define(
		String.prototype,
		{ trimRight: polyfill },
		{ trimRight: function () { return String.prototype.trimRight !== polyfill; } }
	);
	return polyfill;
};

},{"./polyfill":204,"define-properties":198}],206:[function(require,module,exports){
'use strict';

module.exports = require('./es7-shim').shim();

},{"./es7-shim":12}]},{},[206]);</script>
<script>"use strict";

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (e, r) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r((e = "undefined" != typeof globalThis ? globalThis : e || self).graphre = {});
}(void 0, function (e) {
  "use strict";

  var r = /*#__PURE__*/function () {
    function r() {
      _classCallCheck(this, r);

      var e = {};
      e._next = e._prev = e, this._sentinel = e;
    }

    _createClass(r, [{
      key: "dequeue",
      value: function dequeue() {
        var e = this._sentinel,
            r = e._prev;
        if (r !== e) return n(r), r;
      }
    }, {
      key: "enqueue",
      value: function enqueue(e) {
        var r = this._sentinel,
            t = e;
        t._prev && t._next && n(t), t._next = r._next, r._next._prev = t, r._next = t, t._prev = r;
      }
    }, {
      key: "toString",
      value: function toString() {
        for (var e = [], r = this._sentinel, n = r._prev; n !== r;) {
          e.push(JSON.stringify(n, t)), n = n._prev;
        }

        return "[" + e.join(", ") + "]";
      }
    }]);

    return r;
  }();

  function n(e) {
    e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;
  }

  function t(e, r) {
    if ("_next" !== e && "_prev" !== e) return r;
  }

  var o = Object.freeze({
    __proto__: null,
    List: r
  });
  var i = {};

  function a(e) {
    var r = [];

    var _iterator = _createForOfIteratorHelper(e),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var n = _step.value;
        r.push.apply(r, _toConsumableArray(n));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return r;
  }

  function s(e, r) {
    return null != e && e.hasOwnProperty(r);
  }

  function d(e) {
    var r = null == e ? 0 : e.length;
    return r ? e[r - 1] : void 0;
  }

  function u(e, r) {
    e = Object(e);
    var n = {};
    return Object.keys(e).forEach(function (t) {
      n[t] = r(e[t], t);
    }), n;
  }

  function f(e, r) {
    var n = Number.POSITIVE_INFINITY,
        t = void 0;

    var _iterator2 = _createForOfIteratorHelper(e),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var o = _step2.value;
        var i = r(o);
        i < n && (n = i, t = o);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return t;
  }

  function h(e, r) {
    var n = e < r ? 1 : -1;
    var t = -1,
        o = Math.max(Math.ceil((r - e) / (n || 1)), 0);
    var i = new Array(o);

    for (; o--;) {
      i[++t] = e, e += n;
    }

    return i;
  }

  function c(e, r) {
    return e.slice().sort(function (e, n) {
      return r(e) - r(n);
    });
  }

  function v(e) {
    i[e] || (i[e] = 0);
    return "".concat(e).concat(++i[e]);
  }

  function l(e) {
    return e ? Object.keys(e).map(function (r) {
      return e[r];
    }) : [];
  }

  function g(e, r) {
    for (var n = [], t = 0; t < e; t++) {
      n.push(r());
    }

    return n;
  }

  function p(e) {
    return void 0 === e;
  }

  function m(e, r) {
    for (var _i = 0, _Object$keys = Object.keys(e); _i < _Object$keys.length; _i++) {
      var n = _Object$keys[_i];
      r(e[n], n);
    }
  }

  function w(e) {
    return 0 === Object.keys(e).length;
  }

  function _(e) {
    var r = {},
        n = e.nodes().filter(function (r) {
      return !e.children(r).length;
    }),
        t = g(Math.max.apply(Math, _toConsumableArray(n.map(function (r) {
      return e.node(r).rank;
    }))) + 1, function () {
      return [];
    });
    return c(n, function (r) {
      return e.node(r).rank;
    }).forEach(function n(o) {
      if (!s(r, o)) {
        r[o] = !0;
        var i = e.node(o);
        t[i.rank].push(o), e.successors(o).forEach(n);
      }
    }), t;
  }

  function b(e, r) {
    for (var n = 0, t = 1; t < r.length; ++t) {
      n += y(e, r[t - 1], r[t]);
    }

    return n;
  }

  function y(e, r, n) {
    for (var t = {}, o = 0; o < n.length; o++) {
      t[n[o]] = o;
    }

    for (var i = a(r.map(function (r) {
      return c(e.outEdges(r).map(function (r) {
        return {
          pos: t[r.w],
          weight: e.edge(r).weight
        };
      }), function (e) {
        return e.pos;
      });
    })), s = 1; s < n.length;) {
      s <<= 1;
    }

    var d = 2 * s - 1;
    s -= 1;
    var u = g(d, function () {
      return 0;
    }),
        f = 0;
    return i.forEach(function (e) {
      var r = e.pos + s;
      u[r] += e.weight;

      for (var n = 0; r > 0;) {
        r % 2 && (n += u[r + 1]), u[r = r - 1 >> 1] += e.weight;
      }

      f += e.weight * n;
    }), f;
  }

  function k(e, r) {
    return r ? r.map(function (r) {
      var n = e.inEdges(r);

      if (n.length) {
        var t = n.reduce(function (r, n) {
          var t = e.edge(n),
              o = e.node(n.v);
          return {
            sum: r.sum + t.weight * o.order,
            weight: r.weight + t.weight
          };
        }, {
          sum: 0,
          weight: 0
        });
        return {
          v: r,
          barycenter: t.sum / t.weight,
          weight: t.weight
        };
      }

      return {
        v: r
      };
    }) : [];
  }

  function E(e, r) {
    for (var n = {}, t = 0; t < e.length; t++) {
      var o = e[t],
          i = n[o.v] = {
        indegree: 0,
        in: [],
        out: [],
        vs: [o.v],
        i: t
      };
      void 0 !== o.barycenter && (i.barycenter = o.barycenter, i.weight = o.weight);
    }

    var _iterator3 = _createForOfIteratorHelper(r.edges()),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var a = _step3.value;
        var s = n[a.v],
            d = n[a.w];
        void 0 !== s && void 0 !== d && (d.indegree++, s.out.push(n[a.w]));
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return function (e) {
      var r = [];

      function n(e) {
        return function (r) {
          r.merged || (void 0 === r.barycenter || void 0 === e.barycenter || r.barycenter >= e.barycenter) && function (e, r) {
            var n = 0,
                t = 0;
            e.weight && (n += e.barycenter * e.weight, t += e.weight);
            r.weight && (n += r.barycenter * r.weight, t += r.weight);
            e.vs = r.vs.concat(e.vs), e.barycenter = n / t, e.weight = t, e.i = Math.min(r.i, e.i), r.merged = !0;
          }(e, r);
        };
      }

      function t(r) {
        return function (n) {
          n.in.push(r), 0 == --n.indegree && e.push(n);
        };
      }

      for (; e.length;) {
        var o = e.pop();
        r.push(o), o.in.reverse().forEach(n(o)), o.out.forEach(t(o));
      }

      return r.filter(function (e) {
        return !e.merged;
      }).map(function (e) {
        var r = {
          vs: e.vs,
          i: e.i
        };
        return "barycenter" in e && (r.barycenter = e.barycenter), "weight" in e && (r.weight = e.weight), r;
      });
    }(l(n).filter(function (e) {
      return !e.indegree;
    }));
  }

  var N = "\0";

  var x = /*#__PURE__*/function () {
    function x() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, x);

      this._label = void 0, this._nodeCount = 0, this._edgeCount = 0, this._isDirected = !s(e, "directed") || e.directed, this._isMultigraph = !!s(e, "multigraph") && e.multigraph, this._isCompound = !!s(e, "compound") && e.compound, this._defaultNodeLabelFn = function () {}, this._defaultEdgeLabelFn = function () {}, this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children["\0"] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
    }

    _createClass(x, [{
      key: "isDirected",
      value: function isDirected() {
        return this._isDirected;
      }
    }, {
      key: "isMultigraph",
      value: function isMultigraph() {
        return this._isMultigraph;
      }
    }, {
      key: "isCompound",
      value: function isCompound() {
        return this._isCompound;
      }
    }, {
      key: "setGraph",
      value: function setGraph(e) {
        return this._label = e, this;
      }
    }, {
      key: "graph",
      value: function graph() {
        return this._label;
      }
    }, {
      key: "setDefaultNodeLabel",
      value: function setDefaultNodeLabel(e) {
        var r;
        return r = e, this._defaultNodeLabelFn = "function" != typeof r ? function () {
          return e;
        } : e, this;
      }
    }, {
      key: "nodeCount",
      value: function nodeCount() {
        return this._nodeCount;
      }
    }, {
      key: "nodes",
      value: function nodes() {
        return Object.keys(this._nodes);
      }
    }, {
      key: "sources",
      value: function sources() {
        var e = this;
        return this.nodes().filter(function (r) {
          return w(e._in[r]);
        });
      }
    }, {
      key: "sinks",
      value: function sinks() {
        var e = this;
        return this.nodes().filter(function (r) {
          return w(e._out[r]);
        });
      }
    }, {
      key: "setNodes",
      value: function setNodes(e, r) {
        var _iterator4 = _createForOfIteratorHelper(e),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var n = _step4.value;
            void 0 !== r ? this.setNode(n, r) : this.setNode(n);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return this;
      }
    }, {
      key: "setNode",
      value: function setNode(e, r) {
        return s(this._nodes, e) ? (arguments.length > 1 && (this._nodes[e] = r), this) : (this._nodes[e] = arguments.length > 1 ? r : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = N, this._children[e] = {}, this._children["\0"][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);
      }
    }, {
      key: "node",
      value: function node(e) {
        return this._nodes[e];
      }
    }, {
      key: "hasNode",
      value: function hasNode(e) {
        return s(this._nodes, e);
      }
    }, {
      key: "removeNode",
      value: function removeNode(e) {
        var _this = this;

        var r = this;

        if (s(this._nodes, e)) {
          var n = function n(e) {
            r.removeEdge(_this._edgeObjs[e]);
          };

          if (delete this._nodes[e], this._isCompound) {
            var _iterator5 = _createForOfIteratorHelper((this._removeFromParentsChildList(e), delete this._parent[e], this.children(e))),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var t = _step5.value;
                r.setParent(t);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }

            delete this._children[e];
          }

          for (var _i2 = 0, _Object$keys2 = Object.keys(this._in[e]); _i2 < _Object$keys2.length; _i2++) {
            var o = _Object$keys2[_i2];
            n(o);
          }

          for (var _i3 = 0, _arr = (delete this._in[e], delete this._preds[e], Object.keys(this._out[e])); _i3 < _arr.length; _i3++) {
            var o = _arr[_i3];
            n(o);
          }

          delete this._out[e], delete this._sucs[e], --this._nodeCount;
        }

        return this;
      }
    }, {
      key: "setParent",
      value: function setParent(e, r) {
        if (!this._isCompound) throw new Error("Cannot set parent in a non-compound graph");
        if (void 0 === r) r = N;else {
          for (var n = r += ""; !p(n); n = this.parent(n)) {
            if (n === e) throw new Error("Setting ".concat(r, " as parent of ").concat(e, " would create a cycle"));
          }

          this.setNode(r);
        }
        return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = r, this._children[r][e] = !0, this;
      }
    }, {
      key: "_removeFromParentsChildList",
      value: function _removeFromParentsChildList(e) {
        delete this._children[this._parent[e]][e];
      }
    }, {
      key: "parent",
      value: function parent(e) {
        if (this._isCompound) {
          var r = this._parent[e];
          if (r !== N) return r;
        }
      }
    }, {
      key: "children",
      value: function children(e) {
        if (p(e) && (e = N), this._isCompound) {
          var r = this._children[e];
          return r ? Object.keys(r) : void 0;
        }

        return e === N ? this.nodes() : this.hasNode(e) ? [] : void 0;
      }
    }, {
      key: "predecessors",
      value: function predecessors(e) {
        var r = this._preds[e];
        if (r) return Object.keys(r);
      }
    }, {
      key: "successors",
      value: function successors(e) {
        var r = this._sucs[e];
        if (r) return Object.keys(r);
      }
    }, {
      key: "neighbors",
      value: function neighbors(e) {
        var r = this.predecessors(e);
        if (r) return function (e, r) {
          var n = _toConsumableArray(e);

          var _iterator6 = _createForOfIteratorHelper(r),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var t = _step6.value;
              -1 === n.indexOf(t) && n.push(t);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return n;
        }(r, this.successors(e));
      }
    }, {
      key: "isLeaf",
      value: function isLeaf(e) {
        return 0 === (this.isDirected() ? this.successors(e) : this.neighbors(e)).length;
      }
    }, {
      key: "filterNodes",
      value: function filterNodes(e) {
        var r = new x({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        r.setGraph(this.graph());
        var n = this;
        m(this._nodes, function (n, t) {
          e(t) && r.setNode(t, n);
        }), m(this._edgeObjs, function (e) {
          r.hasNode(e.v) && r.hasNode(e.w) && r.setEdge(e, n.edge(e));
        });
        var t = {};

        function o(e) {
          var i = n.parent(e);
          return void 0 === i || r.hasNode(i) ? (t[e] = i, i) : i in t ? t[i] : o(i);
        }

        if (this._isCompound) {
          var _iterator7 = _createForOfIteratorHelper(r.nodes()),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var i = _step7.value;
              r.setParent(i, o(i));
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        }

        return r;
      }
    }, {
      key: "setDefaultEdgeLabel",
      value: function setDefaultEdgeLabel(e) {
        var r;
        return r = e, this._defaultEdgeLabelFn = "function" != typeof r ? function () {
          return e;
        } : e, this;
      }
    }, {
      key: "edgeCount",
      value: function edgeCount() {
        return this._edgeCount;
      }
    }, {
      key: "edges",
      value: function edges() {
        return Object.values(this._edgeObjs);
      }
    }, {
      key: "setPath",
      value: function setPath(e, r) {
        var n = this,
            t = arguments;
        return e.reduce(function (e, o) {
          return t.length > 1 ? n.setEdge(e, o, r) : n.setEdge(e, o), o;
        }), this;
      }
    }, {
      key: "setEdge",
      value: function setEdge(e, r, n, t) {
        var o = !1,
            i = e;
        "object" == _typeof(i) && null !== i && "v" in i ? (e = i.v, r = i.w, t = i.name, 2 === arguments.length && (n = arguments[1], o = !0)) : (e = i, r = arguments[1], t = arguments[3], arguments.length > 2 && (n = arguments[2], o = !0)), e = "" + e, r = "" + r, p(t) || (t = "" + t);
        var a = j(this._isDirected, e, r, t);
        if (s(this._edgeLabels, a)) return o && (this._edgeLabels[a] = n), this;
        if (!p(t) && !this._isMultigraph) throw new Error("Cannot set a named edge when isMultigraph = false");
        this.setNode(e), this.setNode(r), this._edgeLabels[a] = o ? n : this._defaultEdgeLabelFn(e, r, t);

        var d = function (e, r, n, t) {
          var o = "" + r,
              i = "" + n;

          if (!e && o > i) {
            var a = o;
            o = i, i = a;
          }

          var s = {
            v: o,
            w: i
          };
          t && (s.name = t);
          return s;
        }(this._isDirected, e, r, t);

        return e = d.v, r = d.w, Object.freeze(d), this._edgeObjs[a] = d, C(this._preds[r], e), C(this._sucs[e], r), this._in[r][a] = d, this._out[e][a] = d, this._edgeCount++, this;
      }
    }, {
      key: "edge",
      value: function edge(e, r, n) {
        var t = "object" == _typeof(e) ? M(this._isDirected, e) : j(this._isDirected, e, r, n);
        return this._edgeLabels[t];
      }
    }, {
      key: "hasEdge",
      value: function hasEdge(e, r, n) {
        var t = 1 === arguments.length ? M(this._isDirected, arguments[0]) : j(this._isDirected, e, r, n);
        return s(this._edgeLabels, t);
      }
    }, {
      key: "removeEdge",
      value: function removeEdge(e, r, n) {
        var t = "object" == _typeof(e) ? M(this._isDirected, e) : j(this._isDirected, e, r, n),
            o = this._edgeObjs[t];
        return o && (e = o.v, r = o.w, delete this._edgeLabels[t], delete this._edgeObjs[t], O(this._preds[r], e), O(this._sucs[e], r), delete this._in[r][t], delete this._out[e][t], this._edgeCount--), this;
      }
    }, {
      key: "inEdges",
      value: function inEdges(e, r) {
        var n = this._in[e];

        if (n) {
          var t = Object.values(n);
          return r ? t.filter(function (e) {
            return e.v === r;
          }) : t;
        }
      }
    }, {
      key: "outEdges",
      value: function outEdges(e, r) {
        var n = this._out[e];

        if (n) {
          var t = Object.values(n);
          return r ? t.filter(function (e) {
            return e.w === r;
          }) : t;
        }
      }
    }, {
      key: "nodeEdges",
      value: function nodeEdges(e, r) {
        var n = this.inEdges(e, r);
        if (n) return n.concat(this.outEdges(e, r));
      }
    }]);

    return x;
  }();

  var I = /*#__PURE__*/function (_x) {
    _inherits(I, _x);

    var _super = _createSuper(I);

    function I() {
      _classCallCheck(this, I);

      return _super.apply(this, arguments);
    }

    return I;
  }(x);

  function C(e, r) {
    e[r] ? e[r]++ : e[r] = 1;
  }

  function O(e, r) {
    --e[r] || delete e[r];
  }

  function j(e, r, n, t) {
    var o = "" + r,
        i = "" + n;

    if (!e && o > i) {
      var a = o;
      o = i, i = a;
    }

    return o + "" + i + "" + (p(t) ? "\0" : t);
  }

  function M(e, r) {
    return j(e, r.v, r.w, r.name);
  }

  function L(e, r, n, t) {
    var o;

    do {
      o = v(t);
    } while (e.hasNode(o));

    return n.dummy = r, e.setNode(o, n), o;
  }

  function T(e) {
    var r = new x().setGraph(e.graph());

    var _iterator8 = _createForOfIteratorHelper(e.nodes()),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var n = _step8.value;
        r.setNode(n, e.node(n));
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    var _iterator9 = _createForOfIteratorHelper(e.edges()),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var t = _step9.value;
        var o = r.edge(t.v, t.w) || {
          weight: 0,
          minlen: 1
        },
            i = e.edge(t);
        r.setEdge(t.v, t.w, {
          weight: o.weight + i.weight,
          minlen: Math.max(o.minlen, i.minlen)
        });
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }

    return r;
  }

  function S(e) {
    var r = new x({
      multigraph: e.isMultigraph()
    }).setGraph(e.graph());

    var _iterator10 = _createForOfIteratorHelper(e.nodes()),
        _step10;

    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var n = _step10.value;
        e.children(n).length || r.setNode(n, e.node(n));
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }

    var _iterator11 = _createForOfIteratorHelper(e.edges()),
        _step11;

    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var t = _step11.value;
        r.setEdge(t, e.edge(t));
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }

    return r;
  }

  function P(e, r) {
    var n,
        t,
        o = e.x,
        i = e.y,
        a = r.x - o,
        s = r.y - i,
        d = e.width / 2,
        u = e.height / 2;
    if (!a && !s) throw new Error("Not possible to find intersection inside of the rectangle");
    return Math.abs(s) * d > Math.abs(a) * u ? (s < 0 && (u = -u), n = u * a / s, t = u) : (a < 0 && (d = -d), n = d, t = d * s / a), {
      x: o + n,
      y: i + t
    };
  }

  function R(e) {
    var r = g(G(e) + 1, function () {
      return [];
    });

    var _iterator12 = _createForOfIteratorHelper(e.nodes()),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var n = _step12.value;
        var t = e.node(n),
            o = t.rank;
        void 0 !== o && (r[o][t.order] = n);
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    return r;
  }

  function F(e) {
    var r = Math.min.apply(Math, _toConsumableArray(e.nodes().map(function (r) {
      return e.node(r).rank;
    }).filter(function (e) {
      return void 0 !== e;
    })));

    var _iterator13 = _createForOfIteratorHelper(e.nodes()),
        _step13;

    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var n = _step13.value;
        var t = e.node(n);
        s(t, "rank") && (t.rank -= r);
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }
  }

  function D(e) {
    var r = Math.min.apply(Math, _toConsumableArray(e.nodes().map(function (r) {
      return e.node(r).rank;
    }).filter(function (e) {
      return void 0 !== e;
    }))),
        n = [];

    var _iterator14 = _createForOfIteratorHelper(e.nodes()),
        _step14;

    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var t = _step14.value;
        var o = e.node(t).rank - r;
        n[o] || (n[o] = []), n[o].push(t);
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }

    for (var i = 0, a = e.graph().nodeRankFactor, s = 0; s < n.length; s++) {
      var d = n[s];
      if (void 0 === d && s % a != 0) --i;else if (i && null != d) {
        var _iterator15 = _createForOfIteratorHelper(d),
            _step15;

        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var t = _step15.value;
            e.node(t).rank += i;
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
      }
    }
  }

  function z(e, r, n, t) {
    var o = {
      width: 0,
      height: 0
    };
    return arguments.length >= 4 && (o.rank = n, o.order = t), L(e, "border", o, r);
  }

  function G(e) {
    var r = e.nodes().map(function (r) {
      return e.node(r).rank;
    }).filter(function (e) {
      return void 0 !== e;
    });
    return Math.max.apply(Math, _toConsumableArray(r));
  }

  function V(e, r) {
    var n = [],
        t = [];

    var _iterator16 = _createForOfIteratorHelper(e),
        _step16;

    try {
      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
        var o = _step16.value;
        r(o) ? n.push(o) : t.push(o);
      }
    } catch (err) {
      _iterator16.e(err);
    } finally {
      _iterator16.f();
    }

    return {
      lhs: n,
      rhs: t
    };
  }

  function Y(e, r) {
    var n = Date.now();

    try {
      return r();
    } finally {
      console.log(e + " time: " + (Date.now() - n) + "ms");
    }
  }

  function B(e, r) {
    return r();
  }

  var A = Object.freeze({
    __proto__: null,
    addDummyNode: L,
    simplify: T,
    asNonCompoundGraph: S,
    successorWeights: function successorWeights(e) {
      var r = {};

      var _iterator17 = _createForOfIteratorHelper(e.nodes()),
          _step17;

      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var n = _step17.value;
          var t = {};

          var _iterator18 = _createForOfIteratorHelper(e.outEdges(n)),
              _step18;

          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
              var o = _step18.value;
              t[o.w] = (t[o.w] || 0) + e.edge(o).weight;
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }

          r[n] = t;
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }

      return r;
    },
    predecessorWeights: function predecessorWeights(e) {
      var r = {};

      var _iterator19 = _createForOfIteratorHelper(e.nodes()),
          _step19;

      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var n = _step19.value;
          var t = {};

          var _iterator20 = _createForOfIteratorHelper(e.inEdges(n)),
              _step20;

          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var o = _step20.value;
              t[o.v] = (t[o.v] || 0) + e.edge(o).weight;
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }

          r[n] = t;
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }

      return r;
    },
    intersectRect: P,
    buildLayerMatrix: R,
    normalizeRanks: F,
    removeEmptyRanks: D,
    addBorderNode: z,
    maxRank: G,
    partition: V,
    time: Y,
    notime: B
  });

  function q(e, r) {
    var n,
        t = V(e, function (e) {
      return s(e, "barycenter");
    }),
        o = t.lhs,
        i = c(t.rhs, function (e) {
      return -e.i;
    }),
        d = [],
        u = 0,
        f = 0,
        h = 0;

    var _iterator21 = _createForOfIteratorHelper((o.sort((n = !!r, function (e, r) {
      return e.barycenter < r.barycenter ? -1 : e.barycenter > r.barycenter ? 1 : n ? r.i - e.i : e.i - r.i;
    })), h = W(d, i, h), o)),
        _step21;

    try {
      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
        var v = _step21.value;
        h += v.vs.length, d.push(v.vs), u += v.barycenter * v.weight, f += v.weight, h = W(d, i, h);
      }
    } catch (err) {
      _iterator21.e(err);
    } finally {
      _iterator21.f();
    }

    var l = {
      vs: a(d)
    };
    return f && (l.barycenter = u / f, l.weight = f), l;
  }

  function W(e, r, n) {
    for (var t; r.length && (t = d(r)).i <= n;) {
      r.pop(), e.push(t.vs), n++;
    }

    return n;
  }

  function $(e, r, n, t) {
    var o = e.children(r),
        i = e.node(r),
        d = i ? i.borderLeft : void 0,
        u = i ? i.borderRight : void 0,
        f = {};
    d && (o = o.filter(function (e) {
      return e !== d && e !== u;
    }));
    var h = k(e, o);

    var _iterator22 = _createForOfIteratorHelper(h),
        _step22;

    try {
      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
        var c = _step22.value;

        if (e.children(c.v).length) {
          var v = $(e, c.v, n, t);
          f[c.v] = v, s(v, "barycenter") && J(c, v);
        }
      }
    } catch (err) {
      _iterator22.e(err);
    } finally {
      _iterator22.f();
    }

    var l = E(h, n);
    !function (e, r) {
      var _iterator23 = _createForOfIteratorHelper(e),
          _step23;

      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var n = _step23.value;
          n.vs = a(n.vs.map(function (e) {
            return r[e] ? r[e].vs : [e];
          }));
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    }(l, f);
    var g = q(l, t);

    if (d && (g.vs = [d].concat(_toConsumableArray(g.vs), [u]), e.predecessors(d).length)) {
      var p = e.node(e.predecessors(d)[0]),
          m = e.node(e.predecessors(u)[0]);
      s(g, "barycenter") || (g.barycenter = 0, g.weight = 0), g.barycenter = (g.barycenter * g.weight + p.order + m.order) / (g.weight + 2), g.weight += 2;
    }

    return g;
  }

  function J(e, r) {
    void 0 !== e.barycenter ? (e.barycenter = (e.barycenter * e.weight + r.barycenter * r.weight) / (e.weight + r.weight), e.weight += r.weight) : (e.barycenter = r.barycenter, e.weight = r.weight);
  }

  function Q(e, r, n) {
    var t = function (e) {
      var r;

      for (; e.hasNode(r = v("_root"));) {
        ;
      }

      return r;
    }(e),
        o = new x({
      compound: !0
    }).setGraph({
      root: t
    }).setDefaultNodeLabel(function (r) {
      return e.node(r);
    });

    var _iterator24 = _createForOfIteratorHelper(e.nodes()),
        _step24;

    try {
      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
        var i = _step24.value;
        var a = e.node(i),
            d = e.parent(i);

        if (a.rank === r || a.minRank <= r && r <= a.maxRank) {
          var _iterator25 = _createForOfIteratorHelper((o.setNode(i), o.setParent(i, d || t), e[n](i))),
              _step25;

          try {
            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
              var u = _step25.value;
              var f = u.v === i ? u.w : u.v,
                  h = o.edge(f, i),
                  c = void 0 !== h ? h.weight : 0;
              o.setEdge(f, i, {
                weight: e.edge(u).weight + c
              });
            }
          } catch (err) {
            _iterator25.e(err);
          } finally {
            _iterator25.f();
          }

          s(a, "minRank") && o.setNode(i, {
            borderLeft: a.borderLeft[r],
            borderRight: a.borderRight[r]
          });
        }
      }
    } catch (err) {
      _iterator24.e(err);
    } finally {
      _iterator24.f();
    }

    return o;
  }

  function K(e, r, n) {
    var t,
        o = {};

    var _iterator26 = _createForOfIteratorHelper(n),
        _step26;

    try {
      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
        var i = _step26.value;
        !function () {
          for (var n, a = e.parent(i); a;) {
            var s = e.parent(a);
            if (s ? (n = o[s], o[s] = a) : (n = t, t = a), n && n !== a) return void r.setEdge(n, a);
            a = s;
          }
        }();
      }
    } catch (err) {
      _iterator26.e(err);
    } finally {
      _iterator26.f();
    }
  }

  function X(e) {
    var r = G(e),
        n = H(e, h(1, r + 1), "inEdges"),
        t = H(e, h(r - 1, -1), "outEdges"),
        o = _(e);

    Z(e, o);

    for (var i, a = Number.POSITIVE_INFINITY, s = 0, d = 0; d < 4; ++s, ++d) {
      U(s % 2 ? n : t, s % 4 >= 2);
      var u = b(e, o = R(e));
      u < a && (d = 0, i = o.map(function (e) {
        return e.slice(0);
      }), a = u);
    }

    Z(e, i);
  }

  function H(e, r, n) {
    return r.map(function (r) {
      return Q(e, r, n);
    });
  }

  function U(e, r) {
    var n = new x();

    var _iterator27 = _createForOfIteratorHelper(e),
        _step27;

    try {
      for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
        var t = _step27.value;
        var o = t.graph().root,
            i = $(t, o, n, r);
        i.vs.map(function (e, r) {
          t.node(e).order = r;
        }), K(t, n, i.vs);
      }
    } catch (err) {
      _iterator27.e(err);
    } finally {
      _iterator27.f();
    }
  }

  function Z(e, r) {
    var _iterator28 = _createForOfIteratorHelper(r),
        _step28;

    try {
      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
        var n = _step28.value;
        n.map(function (r, n) {
          e.node(r).order = n;
        });
      }
    } catch (err) {
      _iterator28.e(err);
    } finally {
      _iterator28.f();
    }
  }

  var ee = Object.freeze({
    __proto__: null,
    order: X,
    addSubgraphConstraints: K,
    barycenter: k,
    buildLayerGraph: Q,
    crossCount: b,
    initOrder: _,
    resolveConflicts: E,
    sortSubgraph: $,
    sort: q
  });

  function re(e, r) {
    var n = {};
    return r.reduce(function (r, t) {
      for (var o = 0, i = 0, a = r.length, s = d(t), u = 0; u < t.length; u++) {
        var f = t[u],
            h = te(e, f),
            c = h ? e.node(h).order : a;

        if (h || f === s) {
          var _iterator29 = _createForOfIteratorHelper(t.slice(i, u + 1)),
              _step29;

          try {
            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
              var v = _step29.value;

              var _iterator30 = _createForOfIteratorHelper(e.predecessors(v)),
                  _step30;

              try {
                for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                  var l = _step30.value;
                  var g = e.node(l),
                      p = g.order;
                  !(p < o || c < p) || g.dummy && e.node(v).dummy || oe(n, l, v);
                }
              } catch (err) {
                _iterator30.e(err);
              } finally {
                _iterator30.f();
              }
            }
          } catch (err) {
            _iterator29.e(err);
          } finally {
            _iterator29.f();
          }

          i = u + 1, o = c;
        }
      }

      return t;
    }), n;
  }

  function ne(e, r) {
    var n = {};

    function t(r, t, o, i, a) {
      var s;

      var _iterator31 = _createForOfIteratorHelper(h(t, o)),
          _step31;

      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
          var d = _step31.value;

          if (s = r[d], e.node(s).dummy) {
            var _iterator32 = _createForOfIteratorHelper(e.predecessors(s)),
                _step32;

            try {
              for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
                var u = _step32.value;
                var f = e.node(u);
                f.dummy && (f.order < i || f.order > a) && oe(n, u, s);
              }
            } catch (err) {
              _iterator32.e(err);
            } finally {
              _iterator32.f();
            }
          }
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }
    }

    return r.reduce(function (r, n) {
      for (var o, i = -1, a = 0, s = 0; s < n.length; s++) {
        var d = s,
            u = n[s];

        if (void 0 !== u) {
          if ("border" === e.node(u).dummy) {
            var f = e.predecessors(u);
            f.length && (t(n, a, d, i, o = e.node(f[0]).order), a = d, i = o);
          }

          t(n, a, n.length, o, r.length);
        }
      }

      return n;
    }), n;
  }

  function te(e, r) {
    if (e.node(r).dummy) {
      var _iterator33 = _createForOfIteratorHelper(e.predecessors(r)),
          _step33;

      try {
        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
          var n = _step33.value;
          if (e.node(n).dummy) return n;
        }
      } catch (err) {
        _iterator33.e(err);
      } finally {
        _iterator33.f();
      }
    }
  }

  function oe(e, r, n) {
    if (r > n) {
      var t = r;
      r = n, n = t;
    }

    var o = e[r];
    o || (e[r] = o = {}), o[n] = !0;
  }

  function ie(e, r, n) {
    if (r > n) {
      var t = r;
      r = n, n = t;
    }

    return s(e[r], n);
  }

  function ae(e, r, n, t) {
    var o = {},
        i = {},
        a = {};

    var _iterator34 = _createForOfIteratorHelper(r),
        _step34;

    try {
      for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
        var s = _step34.value;

        for (var d = 0; d < s.length; d++) {
          o[f = s[d]] = f, i[f] = f, a[f] = d;
        }
      }
    } catch (err) {
      _iterator34.e(err);
    } finally {
      _iterator34.f();
    }

    var _iterator35 = _createForOfIteratorHelper(r),
        _step35;

    try {
      for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
        var s = _step35.value;
        var u = -1;

        var _iterator36 = _createForOfIteratorHelper(s),
            _step36;

        try {
          for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
            var f = _step36.value;
            var h = t(f);
            if (h.length) for (var v = ((h = c(h, function (e) {
              return a[e];
            })).length - 1) / 2, l = Math.floor(v), g = Math.ceil(v); l <= g; ++l) {
              var p = h[l];
              i[f] === f && u < a[p] && !ie(n, f, p) && (i[p] = f, i[f] = o[f] = o[p], u = a[p]);
            }
          }
        } catch (err) {
          _iterator36.e(err);
        } finally {
          _iterator36.f();
        }
      }
    } catch (err) {
      _iterator35.e(err);
    } finally {
      _iterator35.f();
    }

    return {
      root: o,
      align: i
    };
  }

  function se(e, r, n, t, o) {
    var i = {},
        a = function (e, r, n, t) {
      var o = new x(),
          i = e.graph(),
          a = ce(i.nodesep, i.edgesep, t);

      var _iterator37 = _createForOfIteratorHelper(r),
          _step37;

      try {
        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
          var s = _step37.value;
          var d = null;

          var _iterator38 = _createForOfIteratorHelper(s),
              _step38;

          try {
            for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
              var u = _step38.value;
              var f = n[u];

              if (o.setNode(f), d) {
                var h = n[d],
                    c = o.edge(h, f);
                o.setEdge(h, f, Math.max(a(e, u, d), c || 0));
              }

              d = u;
            }
          } catch (err) {
            _iterator38.e(err);
          } finally {
            _iterator38.f();
          }
        }
      } catch (err) {
        _iterator37.e(err);
      } finally {
        _iterator37.f();
      }

      return o;
    }(e, r, n, o),
        s = o ? "borderLeft" : "borderRight";

    function d(e, r) {
      for (var n = a.nodes(), t = n.pop(), o = {}; t;) {
        o[t] ? e(t) : (o[t] = !0, n.push(t), n = n.concat(r(t))), t = n.pop();
      }
    }

    for (var _i4 = 0, _arr2 = (d(function (e) {
      i[e] = a.inEdges(e).reduce(function (e, r) {
        return Math.max(e, i[r.v] + a.edge(r));
      }, 0);
    }, function (e) {
      return a.predecessors(e);
    }), d(function (r) {
      var n = a.outEdges(r).reduce(function (e, r) {
        return Math.min(e, i[r.w] - a.edge(r));
      }, Number.POSITIVE_INFINITY),
          t = e.node(r);
      n !== Number.POSITIVE_INFINITY && t.borderType !== s && (i[r] = Math.max(i[r], n));
    }, function (e) {
      return a.successors(e);
    }), Object.keys(t)); _i4 < _arr2.length; _i4++) {
      var u = _arr2[_i4];
      var f = t[u];
      i[f] = i[n[f]];
    }

    return i;
  }

  function de(e, r) {
    return f(l(r), function (r) {
      var n = Number.NEGATIVE_INFINITY,
          t = Number.POSITIVE_INFINITY;

      for (var o in r) {
        var i = r[o],
            a = ve(e, o) / 2;
        n = Math.max(i + a, n), t = Math.min(i - a, t);
      }

      return n - t;
    });
  }

  function ue(e, r) {
    var n = l(r),
        t = Math.min.apply(Math, _toConsumableArray(n)),
        o = Math.max.apply(Math, _toConsumableArray(n));

    for (var _i5 = 0, _arr3 = ["ul", "ur", "dl", "dr"]; _i5 < _arr3.length; _i5++) {
      var i = _arr3[_i5];
      var a = i[1],
          s = e[i];

      if (s !== r) {
        var d = l(s),
            f = "l" === a ? t - Math.min.apply(Math, _toConsumableArray(d)) : o - Math.max.apply(Math, _toConsumableArray(d));
        f && (e[i] = u(s, function (e) {
          return e + f;
        }));
      }
    }
  }

  function fe(e, r) {
    return u(e.ul, function (n, t) {
      if (r) return e[r.toLowerCase()][t];
      var o = c([e.ul[t], e.ur[t], e.dl[t], e.dr[t]], function (e) {
        return e;
      });
      return (o[1] + o[2]) / 2;
    });
  }

  function he(e) {
    var r,
        n = R(e),
        t = Object.assign(Object.assign({}, re(e, n)), ne(e, n)),
        o = {
      ul: {},
      ur: {},
      dl: {},
      dr: {}
    };

    for (var _i6 = 0, _arr4 = ["u", "d"]; _i6 < _arr4.length; _i6++) {
      var i = _arr4[_i6];

      for (var _i7 = 0, _arr5 = (r = "u" === i ? n : n.map(function (e) {
        return e;
      }).reverse(), ["l", "r"]); _i7 < _arr5.length; _i7++) {
        var a = _arr5[_i7];
        "r" === a && (r = r.map(function (e) {
          return e.map(function (e) {
            return e;
          }).reverse();
        }));
        var s = ae(0, r, t, ("u" === i ? e.predecessors : e.successors).bind(e)),
            d = se(e, r, s.root, s.align, "r" === a);
        "r" === a && (d = u(d, function (e) {
          return -e;
        })), o[i + a] = d;
      }
    }

    return ue(o, de(e, o)), fe(o, e.graph().align);
  }

  function ce(e, r, n) {
    return function (t, o, i) {
      var a,
          d = t.node(o),
          u = t.node(i),
          f = 0;
      if (f += d.width / 2, s(d, "labelpos")) switch (d.labelpos.toLowerCase()) {
        case "l":
          a = -d.width / 2;
          break;

        case "r":
          a = d.width / 2;
      }
      if (a && (f += n ? a : -a), a = 0, f += (d.dummy ? r : e) / 2, f += (u.dummy ? r : e) / 2, f += u.width / 2, s(u, "labelpos")) switch (u.labelpos.toLowerCase()) {
        case "l":
          a = u.width / 2;
          break;

        case "r":
          a = -u.width / 2;
      }
      return a && (f += n ? a : -a), a = 0, f;
    };
  }

  function ve(e, r) {
    return e.node(r).width;
  }

  var le = Object.freeze({
    __proto__: null,
    findType1Conflicts: re,
    findType2Conflicts: ne,
    findOtherInnerSegmentNode: te,
    addConflict: oe,
    hasConflict: ie,
    verticalAlignment: ae,
    horizontalCompaction: se,
    findSmallestWidthAlignment: de,
    alignCoordinates: ue,
    balance: fe,
    positionX: he,
    sep: ce,
    width: ve
  });

  function ge(e) {
    !function (e) {
      var r = R(e),
          n = e.graph().ranksep,
          t = 0;

      var _iterator39 = _createForOfIteratorHelper(r),
          _step39;

      try {
        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
          var o = _step39.value;
          var i = Math.max.apply(Math, _toConsumableArray(o.map(function (r) {
            return e.node(r).height;
          })));

          var _iterator40 = _createForOfIteratorHelper(o),
              _step40;

          try {
            for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
              var a = _step40.value;
              e.node(a).y = t + i / 2;
            }
          } catch (err) {
            _iterator40.e(err);
          } finally {
            _iterator40.f();
          }

          t += i + n;
        }
      } catch (err) {
        _iterator39.e(err);
      } finally {
        _iterator39.f();
      }
    }(e = S(e));
    var r = he(e);

    for (var n in r) {
      e.node(n).x = r[n];
    }
  }

  var pe = Object.freeze({
    __proto__: null,
    bk: le,
    position: ge
  });

  function me(e) {
    var r = {};
    e.sources().forEach(function n(t) {
      var o = e.node(t);
      if (s(r, t)) return o.rank;
      r[t] = !0;
      var i = Math.min.apply(Math, _toConsumableArray(e.outEdges(t).map(function (r) {
        return n(r.w) - e.edge(r).minlen;
      })));
      return i !== Number.POSITIVE_INFINITY && null != i || (i = 0), o.rank = i;
    });
  }

  function we(e, r) {
    return e.node(r.w).rank - e.node(r.v).rank - e.edge(r).minlen;
  }

  function _e(e) {
    var r,
        n = new x({
      directed: !1
    }),
        t = e.nodes()[0],
        o = e.nodeCount();

    for (n.setNode(t, {}); i(e) < o;) {
      r = a(e), s(e, n.hasNode(r.v) ? we(e, r) : -we(e, r));
    }

    return n;

    function i(e) {
      return n.nodes().forEach(function r(t) {
        var _iterator41 = _createForOfIteratorHelper(e.nodeEdges(t)),
            _step41;

        try {
          for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
            var o = _step41.value;
            var i = o.v,
                a = t === i ? o.w : i;
            n.hasNode(a) || we(e, o) || (n.setNode(a, {}), n.setEdge(t, a, {}), r(a));
          }
        } catch (err) {
          _iterator41.e(err);
        } finally {
          _iterator41.f();
        }
      }), n.nodeCount();
    }

    function a(e) {
      return f(e.edges(), function (r) {
        if (n.hasNode(r.v) !== n.hasNode(r.w)) return we(e, r);
      });
    }

    function s(e, r) {
      var _iterator42 = _createForOfIteratorHelper(n.nodes()),
          _step42;

      try {
        for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
          var t = _step42.value;
          e.node(t).rank += r;
        }
      } catch (err) {
        _iterator42.e(err);
      } finally {
        _iterator42.f();
      }
    }
  }

  var be = /*#__PURE__*/function () {
    function be() {
      _classCallCheck(this, be);

      this._arr = [], this._keyIndices = {};
    }

    _createClass(be, [{
      key: "size",
      value: function size() {
        return this._arr.length;
      }
    }, {
      key: "keys",
      value: function keys() {
        return this._arr.map(function (e) {
          return e.key;
        });
      }
    }, {
      key: "has",
      value: function has(e) {
        return e in this._keyIndices;
      }
    }, {
      key: "priority",
      value: function priority(e) {
        var r = this._keyIndices[e];
        if (void 0 !== r) return this._arr[r].priority;
      }
    }, {
      key: "min",
      value: function min() {
        if (0 === this.size()) throw new Error("Queue underflow");
        return this._arr[0].key;
      }
    }, {
      key: "add",
      value: function add(e, r) {
        var n = this._keyIndices;

        if (!((e = String(e)) in n)) {
          var t = this._arr,
              o = t.length;
          return n[e] = o, t.push({
            key: e,
            priority: r
          }), this._decrease(o), !0;
        }

        return !1;
      }
    }, {
      key: "removeMin",
      value: function removeMin() {
        this._swap(0, this._arr.length - 1);

        var e = this._arr.pop();

        return delete this._keyIndices[e.key], this._heapify(0), e.key;
      }
    }, {
      key: "decrease",
      value: function decrease(e, r) {
        var n = this._keyIndices[e];
        if (r > this._arr[n].priority) throw new Error("New priority is greater than current priority. Key: " + e + " Old: " + this._arr[n].priority + " New: " + r);
        this._arr[n].priority = r, this._decrease(n);
      }
    }, {
      key: "_heapify",
      value: function _heapify(e) {
        var r = this._arr,
            n = 2 * e,
            t = n + 1,
            o = e;
        n < r.length && (o = r[n].priority < r[o].priority ? n : o, t < r.length && (o = r[t].priority < r[o].priority ? t : o), o !== e && (this._swap(e, o), this._heapify(o)));
      }
    }, {
      key: "_decrease",
      value: function _decrease(e) {
        for (var r, n = this._arr, t = n[e].priority; 0 !== e && !(n[r = e >> 1].priority < t);) {
          this._swap(e, r), e = r;
        }
      }
    }, {
      key: "_swap",
      value: function _swap(e, r) {
        var n = this._arr,
            t = this._keyIndices,
            o = n[e],
            i = n[r];
        n[e] = i, n[r] = o, t[i.key] = e, t[o.key] = r;
      }
    }]);

    return be;
  }();

  var ye = function ye() {
    return 1;
  };

  function ke(e, r, n, t) {
    return function (e, r, n, t) {
      var o,
          i,
          a = {},
          s = new be(),
          d = function d(e) {
        var r = e.v !== o ? e.v : e.w,
            t = a[r],
            d = n(e),
            u = i.distance + d;
        if (d < 0) throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e + " Weight: " + d);
        u < t.distance && (t.distance = u, t.predecessor = o, s.decrease(r, u));
      };

      e.nodes().forEach(function (e) {
        var n = e === r ? 0 : Number.POSITIVE_INFINITY;
        a[e] = {
          distance: n
        }, s.add(e, n);
      });

      for (; s.size() > 0 && (o = s.removeMin(), (i = a[o]).distance !== Number.POSITIVE_INFINITY);) {
        t(o).forEach(d);
      }

      return a;
    }(e, String(r), n || ye, t || function (r) {
      return e.outEdges(r);
    });
  }

  function Ee(e) {
    var r = 0,
        n = [],
        t = {},
        o = [];

    function i(a) {
      var s = t[a] = {
        onStack: !0,
        lowlink: r,
        index: r++
      };

      if (n.push(a), e.successors(a).forEach(function (e) {
        e in t ? t[e].onStack && (s.lowlink = Math.min(s.lowlink, t[e].index)) : (i(e), s.lowlink = Math.min(s.lowlink, t[e].lowlink));
      }), s.lowlink === s.index) {
        var d,
            u = [];

        do {
          d = n.pop(), t[d].onStack = !1, u.push(d);
        } while (a !== d);

        o.push(u);
      }
    }

    return e.nodes().forEach(function (e) {
      e in t || i(e);
    }), o;
  }

  var Ne = function Ne() {
    return 1;
  };

  var xe = /*#__PURE__*/function (_Error) {
    _inherits(xe, _Error);

    var _super2 = _createSuper(xe);

    function xe() {
      _classCallCheck(this, xe);

      return _super2.apply(this, arguments);
    }

    return xe;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function Ie(e) {
    var r = {},
        n = {},
        t = [];

    function o(i) {
      if (i in n) throw new xe();

      if (!(i in r)) {
        var _iterator43 = _createForOfIteratorHelper((n[i] = !0, r[i] = !0, e.predecessors(i))),
            _step43;

        try {
          for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
            var a = _step43.value;
            o(a);
          }
        } catch (err) {
          _iterator43.e(err);
        } finally {
          _iterator43.f();
        }

        delete n[i], t.push(i);
      }
    }

    var _iterator44 = _createForOfIteratorHelper(e.sinks()),
        _step44;

    try {
      for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
        var i = _step44.value;
        o(i);
      }
    } catch (err) {
      _iterator44.e(err);
    } finally {
      _iterator44.f();
    }

    if (Object.keys(r).length !== e.nodeCount()) throw new xe();
    return t;
  }

  function Ce(e, r, n) {
    var t = Array.isArray(r) ? r : [r],
        o = (e.isDirected() ? e.successors : e.neighbors).bind(e),
        i = [],
        a = {};

    var _iterator45 = _createForOfIteratorHelper(t),
        _step45;

    try {
      for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
        var s = _step45.value;
        if (!e.hasNode(s)) throw new Error("Graph does not have node: " + s);
        Oe(e, s, "post" === n, a, o, i);
      }
    } catch (err) {
      _iterator45.e(err);
    } finally {
      _iterator45.f();
    }

    return i;
  }

  function Oe(e, r, n, t, o, i) {
    if (!(r in t)) {
      var _iterator46 = _createForOfIteratorHelper((t[r] = !0, n || i.push(r), o(r))),
          _step46;

      try {
        for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
          var a = _step46.value;
          Oe(e, a, n, t, o, i);
        }
      } catch (err) {
        _iterator46.e(err);
      } finally {
        _iterator46.f();
      }

      n && i.push(r);
    }
  }

  function je(e, r) {
    return Ce(e, r, "post");
  }

  function Me(e, r) {
    return Ce(e, r, "pre");
  }

  var Le = Object.freeze({
    __proto__: null,
    components: function components(e) {
      var r,
          n = {},
          t = [];

      function o(t) {
        if (!(t in n)) {
          var _iterator47 = _createForOfIteratorHelper((n[t] = !0, r.push(t), e.successors(t))),
              _step47;

          try {
            for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
              var i = _step47.value;
              o(i);
            }
          } catch (err) {
            _iterator47.e(err);
          } finally {
            _iterator47.f();
          }

          var _iterator48 = _createForOfIteratorHelper(e.predecessors(t)),
              _step48;

          try {
            for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
              var a = _step48.value;
              o(a);
            }
          } catch (err) {
            _iterator48.e(err);
          } finally {
            _iterator48.f();
          }
        }
      }

      var _iterator49 = _createForOfIteratorHelper(e.nodes()),
          _step49;

      try {
        for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
          var i = _step49.value;
          r = [], o(i), r.length && t.push(r);
        }
      } catch (err) {
        _iterator49.e(err);
      } finally {
        _iterator49.f();
      }

      return t;
    },
    dijkstra: ke,
    dijkstraAll: function dijkstraAll(e, r, n) {
      var t = {};

      var _iterator50 = _createForOfIteratorHelper(e.nodes()),
          _step50;

      try {
        for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
          var o = _step50.value;
          t[o] = ke(e, o, r, n);
        }
      } catch (err) {
        _iterator50.e(err);
      } finally {
        _iterator50.f();
      }

      return t;
    },
    findCycles: function findCycles(e) {
      return Ee(e).filter(function (r) {
        return r.length > 1 || 1 === r.length && e.hasEdge(r[0], r[0]);
      });
    },
    floydWarshall: function floydWarshall(e, r, n) {
      return function (e, r, n) {
        var t = {},
            o = e.nodes();
        return o.forEach(function (e) {
          t[e] = {}, t[e][e] = {
            distance: 0
          }, o.forEach(function (r) {
            e !== r && (t[e][r] = {
              distance: Number.POSITIVE_INFINITY
            });
          }), n(e).forEach(function (n) {
            var o = n.v === e ? n.w : n.v,
                i = r(n);
            t[e][o] = {
              distance: i,
              predecessor: e
            };
          });
        }), o.forEach(function (e) {
          var r = t[e];
          o.forEach(function (n) {
            var i = t[n];
            o.forEach(function (n) {
              var t = i[e],
                  o = r[n],
                  a = i[n],
                  s = t.distance + o.distance;
              s < a.distance && (a.distance = s, a.predecessor = o.predecessor);
            });
          });
        }), t;
      }(e, r || Ne, n || function (r) {
        return e.outEdges(r);
      });
    },
    isAcyclic: function isAcyclic(e) {
      try {
        Ie(e);
      } catch (e) {
        if (_instanceof(e, xe)) return !1;
        throw e;
      }

      return !0;
    },
    postorder: je,
    preorder: Me,
    prim: function prim(e, r) {
      var n,
          t = new I({}),
          o = {},
          i = new be();

      function a(e) {
        var t = e.v === n ? e.w : e.v,
            a = i.priority(t);

        if (void 0 !== a) {
          var s = r(e);
          s < a && (o[t] = n, i.decrease(t, s));
        }
      }

      if (0 === e.nodeCount()) return t;

      var _iterator51 = _createForOfIteratorHelper(e.nodes()),
          _step51;

      try {
        for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
          n = _step51.value;
          i.add(n, Number.POSITIVE_INFINITY), t.setNode(n);
        }
      } catch (err) {
        _iterator51.e(err);
      } finally {
        _iterator51.f();
      }

      i.decrease(e.nodes()[0], 0);

      for (var s = !1; i.size() > 0;) {
        if ((n = i.removeMin()) in o) t.setEdge(n, o[n]);else {
          if (s) throw new Error("Input graph is not connected: " + e);
          s = !0;
        }
        e.nodeEdges(n).forEach(a);
      }

      return t;
    },
    tarjan: Ee,
    topsort: Ie
  });

  function Te(e) {
    me(e = T(e));

    var r,
        n = _e(e);

    for (Fe(n), Se(n, e); r = ze(n);) {
      Ve(n, e, r, Ge(n, e, r));
    }
  }

  function Se(e, r) {
    var n = je(e, e.nodes());

    var _iterator52 = _createForOfIteratorHelper(n = n.slice(0, n.length - 1)),
        _step52;

    try {
      for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
        var t = _step52.value;
        Pe(e, r, t);
      }
    } catch (err) {
      _iterator52.e(err);
    } finally {
      _iterator52.f();
    }
  }

  function Pe(e, r, n) {
    var t = e.node(n).parent;
    e.edge(n, t).cutvalue = Re(e, r, n);
  }

  function Re(e, r, n) {
    var t,
        o,
        i = e.node(n).parent,
        a = !0,
        s = r.edge(n, i),
        d = 0;

    var _iterator53 = _createForOfIteratorHelper((s || (a = !1, s = r.edge(i, n)), d = s.weight, r.nodeEdges(n))),
        _step53;

    try {
      for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
        var u = _step53.value;
        var f = u.v === n,
            h = f ? u.w : u.v;

        if (h !== i) {
          var c = f === a,
              v = r.edge(u).weight;

          if (d += c ? v : -v, t = n, o = h, e.hasEdge(t, o)) {
            var l = e.edge(n, h).cutvalue;
            d += c ? -l : l;
          }
        }
      }
    } catch (err) {
      _iterator53.e(err);
    } finally {
      _iterator53.f();
    }

    return d;
  }

  function Fe(e, r) {
    arguments.length < 2 && (r = e.nodes()[0]), De(e, {}, 1, r);
  }

  function De(e, r, n, t, o) {
    var i = n,
        a = e.node(t);

    var _iterator54 = _createForOfIteratorHelper((r[t] = !0, e.neighbors(t))),
        _step54;

    try {
      for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
        var d = _step54.value;
        s(r, d) || (n = De(e, r, n, d, t));
      }
    } catch (err) {
      _iterator54.e(err);
    } finally {
      _iterator54.f();
    }

    return a.low = i, a.lim = n++, o ? a.parent = o : delete a.parent, n;
  }

  function ze(e) {
    var _iterator55 = _createForOfIteratorHelper(e.edges()),
        _step55;

    try {
      for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
        var r = _step55.value;
        if (e.edge(r).cutvalue < 0) return r;
      }
    } catch (err) {
      _iterator55.e(err);
    } finally {
      _iterator55.f();
    }
  }

  function Ge(e, r, n) {
    var t = n.v,
        o = n.w;
    r.hasEdge(t, o) || (t = n.w, o = n.v);
    var i = e.node(t),
        a = e.node(o),
        s = i,
        d = !1;
    return i.lim > a.lim && (s = a, d = !0), f(r.edges().filter(function (r) {
      return d === Ye(e, e.node(r.v), s) && d !== Ye(e, e.node(r.w), s);
    }), function (e) {
      return we(r, e);
    });
  }

  function Ve(e, r, n, t) {
    var o = n.v,
        i = n.w;
    e.removeEdge(o, i), e.setEdge(t.v, t.w, {}), Fe(e), Se(e, r), function (e, r) {
      var n = function (e, r) {
        var _iterator56 = _createForOfIteratorHelper(e.nodes()),
            _step56;

        try {
          for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
            var n = _step56.value;
            if (!r.node(n).parent) return n;
          }
        } catch (err) {
          _iterator56.e(err);
        } finally {
          _iterator56.f();
        }

        return;
      }(e, r),
          t = Me(e, n);

      var _iterator57 = _createForOfIteratorHelper(t = t.slice(1)),
          _step57;

      try {
        for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
          var o = _step57.value;
          var i = e.node(o).parent,
              a = r.edge(o, i),
              s = !1;
          a || (a = r.edge(i, o), s = !0), r.node(o).rank = r.node(i).rank + (s ? a.minlen : -a.minlen);
        }
      } catch (err) {
        _iterator57.e(err);
      } finally {
        _iterator57.f();
      }
    }(e, r);
  }

  function Ye(e, r, n) {
    return n.low <= r.lim && r.lim <= n.lim;
  }

  function Be(e) {
    switch (e.graph().ranker) {
      case "network-simplex":
        We(e);
        break;

      case "tight-tree":
        qe(e);
        break;

      case "longest-path":
        Ae(e);
        break;

      default:
        We(e);
    }
  }

  Te.initLowLimValues = Fe, Te.initCutValues = Se, Te.calcCutValue = Re, Te.leaveEdge = ze, Te.enterEdge = Ge, Te.exchangeEdges = Ve;
  var Ae = me;

  function qe(e) {
    me(e), _e(e);
  }

  function We(e) {
    Te(e);
  }

  var $e = Object.freeze({
    __proto__: null,
    rank: Be,
    tightTreeRanker: qe,
    networkSimplexRanker: We,
    networkSimplex: Te,
    feasibleTree: _e,
    longestPath: me
  }),
      Je = function Je(e) {
    return 1;
  };

  function Qe(e, n) {
    if (e.nodeCount() <= 1) return [];

    var t = function (e, n) {
      var t = new x(),
          o = 0,
          i = 0;

      var _iterator58 = _createForOfIteratorHelper(e.nodes()),
          _step58;

      try {
        for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
          var a = _step58.value;
          t.setNode(a, {
            v: a,
            in: 0,
            out: 0
          });
        }
      } catch (err) {
        _iterator58.e(err);
      } finally {
        _iterator58.f();
      }

      var _iterator59 = _createForOfIteratorHelper(e.edges()),
          _step59;

      try {
        for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
          var s = _step59.value;
          var d = t.edge(s.v, s.w) || 0,
              u = n(s),
              f = d + u;
          t.setEdge(s.v, s.w, f), i = Math.max(i, t.node(s.v).out += u), o = Math.max(o, t.node(s.w).in += u);
        }
      } catch (err) {
        _iterator59.e(err);
      } finally {
        _iterator59.f();
      }

      var h = g(i + o + 3, function () {
        return new r();
      }),
          c = o + 1;

      var _iterator60 = _createForOfIteratorHelper(t.nodes()),
          _step60;

      try {
        for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
          var a = _step60.value;
          Xe(h, c, t.node(a));
        }
      } catch (err) {
        _iterator60.e(err);
      } finally {
        _iterator60.f();
      }

      return {
        graph: t,
        buckets: h,
        zeroIdx: c
      };
    }(e, n || Je);

    return a(function (e, r, n) {
      var t,
          o = [],
          i = r[r.length - 1],
          a = r[0];

      for (; e.nodeCount();) {
        for (; t = a.dequeue();) {
          Ke(e, r, n, t);
        }

        for (; t = i.dequeue();) {
          Ke(e, r, n, t);
        }

        if (e.nodeCount()) for (var s = r.length - 2; s > 0; --s) {
          if (t = r[s].dequeue()) {
            o = o.concat(Ke(e, r, n, t, !0));
            break;
          }
        }
      }

      return o;
    }(t.graph, t.buckets, t.zeroIdx).map(function (r) {
      return e.outEdges(r.v, r.w);
    }));
  }

  function Ke(e, r, n, t, o) {
    var i = o ? [] : void 0;

    var _iterator61 = _createForOfIteratorHelper(e.inEdges(t.v)),
        _step61;

    try {
      for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {
        var a = _step61.value;
        var s = e.edge(a),
            d = e.node(a.v);
        o && i.push({
          v: a.v,
          w: a.w
        }), d.out -= s, Xe(r, n, d);
      }
    } catch (err) {
      _iterator61.e(err);
    } finally {
      _iterator61.f();
    }

    var _iterator62 = _createForOfIteratorHelper(e.outEdges(t.v)),
        _step62;

    try {
      for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
        var a = _step62.value;
        s = e.edge(a);
        var u = a.w,
            f = e.node(u);
        f.in -= s, Xe(r, n, f);
      }
    } catch (err) {
      _iterator62.e(err);
    } finally {
      _iterator62.f();
    }

    return e.removeNode(t.v), i;
  }

  function Xe(e, r, n) {
    n.out ? n.in ? e[n.out - n.in + r].enqueue(n) : e[e.length - 1].enqueue(n) : e[0].enqueue(n);
  }

  var He = {
    run: function run(e) {
      var r = "greedy" === e.graph().acyclicer ? Qe(e, function (e) {
        return function (r) {
          return e.edge(r).weight;
        };
      }(e)) : function (e) {
        var r = [],
            n = {},
            t = {};

        function o(i) {
          if (!s(t, i)) {
            var _iterator63 = _createForOfIteratorHelper((t[i] = !0, n[i] = !0, e.outEdges(i))),
                _step63;

            try {
              for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
                var a = _step63.value;
                s(n, a.w) ? r.push(a) : o(a.w);
              }
            } catch (err) {
              _iterator63.e(err);
            } finally {
              _iterator63.f();
            }

            delete n[i];
          }
        }

        return e.nodes().forEach(o), r;
      }(e);

      var _iterator64 = _createForOfIteratorHelper(r),
          _step64;

      try {
        for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {
          var n = _step64.value;
          var t = e.edge(n);
          e.removeEdge(n), t.forwardName = n.name, t.reversed = !0, e.setEdge(n.w, n.v, t, v("rev"));
        }
      } catch (err) {
        _iterator64.e(err);
      } finally {
        _iterator64.f();
      }
    },
    undo: function undo(e) {
      var _iterator65 = _createForOfIteratorHelper(e.edges()),
          _step65;

      try {
        for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
          var r = _step65.value;
          var n = e.edge(r);

          if (n.reversed) {
            e.removeEdge(r);
            var t = n.forwardName;
            delete n.reversed, delete n.forwardName, e.setEdge(r.w, r.v, n, t);
          }
        }
      } catch (err) {
        _iterator65.e(err);
      } finally {
        _iterator65.f();
      }
    }
  };

  function Ue(e) {
    e.children().forEach(function r(n) {
      var t = e.children(n),
          o = e.node(n);

      if (t.length && t.forEach(r), s(o, "minRank")) {
        o.borderLeft = [], o.borderRight = [];

        for (var i = o.minRank, a = o.maxRank + 1; i < a; ++i) {
          Ze(e, "borderLeft", "_bl", n, o, i), Ze(e, "borderRight", "_br", n, o, i);
        }
      }
    });
  }

  function Ze(e, r, n, t, o, i) {
    var a = {
      width: 0,
      height: 0,
      rank: i,
      borderType: r
    },
        s = o[r][i - 1],
        d = L(e, "border", a, n);
    o[r][i] = d, e.setParent(d, t), s && e.setEdge(s, d, {
      weight: 1
    });
  }

  var er = {
    adjust: function adjust(e) {
      var r = e.graph().rankdir.toLowerCase();
      "lr" !== r && "rl" !== r || rr(e);
    },
    undo: function undo(e) {
      var r = e.graph().rankdir.toLowerCase();
      "bt" !== r && "rl" !== r || function (e) {
        var _iterator66 = _createForOfIteratorHelper(e.nodes()),
            _step66;

        try {
          for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
            var r = _step66.value;
            tr(e.node(r));
          }
        } catch (err) {
          _iterator66.e(err);
        } finally {
          _iterator66.f();
        }

        var _iterator67 = _createForOfIteratorHelper(e.edges()),
            _step67;

        try {
          for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {
            var n = _step67.value;
            var t = e.edge(n);
            t.points.forEach(tr), s(t, "y") && tr(t);
          }
        } catch (err) {
          _iterator67.e(err);
        } finally {
          _iterator67.f();
        }
      }(e);
      "lr" !== r && "rl" !== r || (!function (e) {
        var _iterator68 = _createForOfIteratorHelper(e.nodes()),
            _step68;

        try {
          for (_iterator68.s(); !(_step68 = _iterator68.n()).done;) {
            var r = _step68.value;
            or(e.node(r));
          }
        } catch (err) {
          _iterator68.e(err);
        } finally {
          _iterator68.f();
        }

        var _iterator69 = _createForOfIteratorHelper(e.edges()),
            _step69;

        try {
          for (_iterator69.s(); !(_step69 = _iterator69.n()).done;) {
            var n = _step69.value;
            var t = e.edge(n);
            t.points.forEach(or), s(t, "x") && or(t);
          }
        } catch (err) {
          _iterator69.e(err);
        } finally {
          _iterator69.f();
        }
      }(e), rr(e));
    }
  };

  function rr(e) {
    var _iterator70 = _createForOfIteratorHelper(e.nodes()),
        _step70;

    try {
      for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {
        var r = _step70.value;
        nr(e.node(r));
      }
    } catch (err) {
      _iterator70.e(err);
    } finally {
      _iterator70.f();
    }

    var _iterator71 = _createForOfIteratorHelper(e.edges()),
        _step71;

    try {
      for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {
        var n = _step71.value;
        nr(e.edge(n));
      }
    } catch (err) {
      _iterator71.e(err);
    } finally {
      _iterator71.f();
    }
  }

  function nr(e) {
    var r = e.width;
    e.width = e.height, e.height = r;
  }

  function tr(e) {
    e.y = -e.y;
  }

  function or(e) {
    var r = e.x;
    e.x = e.y, e.y = r;
  }

  var ir = Object.freeze({
    __proto__: null,
    debugOrdering: function debugOrdering(e) {
      var r = R(e),
          n = new x({
        compound: !0,
        multigraph: !0
      }).setGraph({});

      var _iterator72 = _createForOfIteratorHelper(e.nodes()),
          _step72;

      try {
        for (_iterator72.s(); !(_step72 = _iterator72.n()).done;) {
          var t = _step72.value;
          n.setNode(t, {
            label: t
          }), n.setParent(t, "layer" + e.node(t).rank);
        }
      } catch (err) {
        _iterator72.e(err);
      } finally {
        _iterator72.f();
      }

      var _iterator73 = _createForOfIteratorHelper(e.edges()),
          _step73;

      try {
        for (_iterator73.s(); !(_step73 = _iterator73.n()).done;) {
          var o = _step73.value;
          n.setEdge(o.v, o.w, {}, o.name);
        }
      } catch (err) {
        _iterator73.e(err);
      } finally {
        _iterator73.f();
      }

      var i = 0;

      var _iterator74 = _createForOfIteratorHelper(r),
          _step74;

      try {
        for (_iterator74.s(); !(_step74 = _iterator74.n()).done;) {
          var a = _step74.value;
          var s = "layer" + i;
          i++, n.setNode(s, {
            rank: "same"
          }), a.reduce(function (e, r) {
            return n.setEdge(e.toString(), r, {
              style: "invis"
            }), r;
          });
        }
      } catch (err) {
        _iterator74.e(err);
      } finally {
        _iterator74.f();
      }

      return n;
    }
  }),
      ar = {
    run: function run(e) {
      var _iterator75 = _createForOfIteratorHelper((e.graph().dummyChains = [], e.edges())),
          _step75;

      try {
        for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {
          var r = _step75.value;
          sr(e, r);
        }
      } catch (err) {
        _iterator75.e(err);
      } finally {
        _iterator75.f();
      }
    },
    undo: function undo(e) {
      var _iterator76 = _createForOfIteratorHelper(e.graph().dummyChains),
          _step76;

      try {
        for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {
          var r = _step76.value;
          var n,
              t = e.node(r),
              o = t.edgeLabel;

          for (e.setEdge(t.edgeObj, o); t.dummy;) {
            n = e.successors(r)[0], e.removeNode(r), o.points.push({
              x: t.x,
              y: t.y
            }), "edge-label" === t.dummy && (o.x = t.x, o.y = t.y, o.width = t.width, o.height = t.height), r = n, t = e.node(r);
          }
        }
      } catch (err) {
        _iterator76.e(err);
      } finally {
        _iterator76.f();
      }
    }
  };

  function sr(e, r) {
    var n = r.v,
        t = e.node(n).rank,
        o = r.w,
        i = e.node(o).rank,
        a = r.name,
        s = e.edge(r),
        d = s.labelRank;

    if (i !== t + 1) {
      var u, f, h;

      for (e.removeEdge(r), h = 0, ++t; t < i; ++h, ++t) {
        s.points = [], u = L(e, "edge", f = {
          width: 0,
          height: 0,
          edgeLabel: s,
          edgeObj: r,
          rank: t
        }, "_d"), t === d && (f.width = s.width, f.height = s.height, f.dummy = "edge-label", f.labelpos = s.labelpos), e.setEdge(n, u, {
          weight: s.weight
        }, a), 0 === h && e.graph().dummyChains.push(u), n = u;
      }

      e.setEdge(n, o, {
        weight: s.weight
      }, a);
    }
  }

  function dr(e) {
    var r = function (e) {
      var r = {},
          n = 0;

      function t(o) {
        var i = n;
        e.children(o).forEach(t), r[o] = {
          low: i,
          lim: n++
        };
      }

      return e.children().forEach(t), r;
    }(e);

    var _iterator77 = _createForOfIteratorHelper(e.graph().dummyChains),
        _step77;

    try {
      for (_iterator77.s(); !(_step77 = _iterator77.n()).done;) {
        var n = _step77.value;

        for (var t = e.node(n), o = t.edgeObj, i = ur(e, r, o.v, o.w), a = i.path, s = i.lca, d = 0, u = a[d], f = !0; n !== o.w;) {
          if (t = e.node(n), f) {
            for (; (u = a[d]) !== s && e.node(u).maxRank < t.rank;) {
              d++;
            }

            u === s && (f = !1);
          }

          if (!f) {
            for (; d < a.length - 1 && e.node(u = a[d + 1]).minRank <= t.rank;) {
              d++;
            }

            u = a[d];
          }

          e.setParent(n, u), n = e.successors(n)[0];
        }
      }
    } catch (err) {
      _iterator77.e(err);
    } finally {
      _iterator77.f();
    }
  }

  function ur(e, r, n, t) {
    var o,
        i,
        a = [],
        s = [],
        d = Math.min(r[n].low, r[t].low),
        u = Math.max(r[n].lim, r[t].lim);
    o = n;

    do {
      o = e.parent(o), a.push(o);
    } while (o && (r[o].low > d || u > r[o].lim));

    for (i = o, o = t; (o = e.parent(o)) !== i;) {
      s.push(o);
    }

    return {
      path: a.concat(s.reverse()),
      lca: i
    };
  }

  var fr = {
    run: function run(e) {
      var r = L(e, "root", {}, "_root"),
          n = function (e) {
        var r = {};

        function n(t, o) {
          var i = e.children(t);

          if (i && i.length) {
            var _iterator78 = _createForOfIteratorHelper(i),
                _step78;

            try {
              for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {
                var a = _step78.value;
                n(a, o + 1);
              }
            } catch (err) {
              _iterator78.e(err);
            } finally {
              _iterator78.f();
            }
          }

          r[t] = o;
        }

        var _iterator79 = _createForOfIteratorHelper(e.children()),
            _step79;

        try {
          for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {
            var t = _step79.value;
            n(t, 1);
          }
        } catch (err) {
          _iterator79.e(err);
        } finally {
          _iterator79.f();
        }

        return r;
      }(e),
          t = Math.max.apply(Math, _toConsumableArray(l(n))) - 1,
          o = 2 * t + 1;

      var _iterator80 = _createForOfIteratorHelper((e.graph().nestingRoot = r, e.edges())),
          _step80;

      try {
        for (_iterator80.s(); !(_step80 = _iterator80.n()).done;) {
          var i = _step80.value;
          e.edge(i).minlen *= o;
        }
      } catch (err) {
        _iterator80.e(err);
      } finally {
        _iterator80.f();
      }

      var a = function (e) {
        return e.edges().reduce(function (r, n) {
          return r + e.edge(n).weight;
        }, 0);
      }(e) + 1;

      var _iterator81 = _createForOfIteratorHelper(e.children()),
          _step81;

      try {
        for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {
          var s = _step81.value;
          hr(e, r, o, a, t, n, s);
        }
      } catch (err) {
        _iterator81.e(err);
      } finally {
        _iterator81.f();
      }

      e.graph().nodeRankFactor = o;
    },
    cleanup: function cleanup(e) {
      var r = e.graph();

      var _iterator82 = _createForOfIteratorHelper((e.removeNode(r.nestingRoot), delete r.nestingRoot, e.edges())),
          _step82;

      try {
        for (_iterator82.s(); !(_step82 = _iterator82.n()).done;) {
          var n = _step82.value;
          e.edge(n).nestingEdge && e.removeEdge(n);
        }
      } catch (err) {
        _iterator82.e(err);
      } finally {
        _iterator82.f();
      }
    }
  };

  function hr(e, r, n, t, o, i, a) {
    var s = e.children(a);

    if (s.length) {
      var d = z(e, "_bt"),
          u = z(e, "_bb"),
          f = e.node(a);

      var _iterator83 = _createForOfIteratorHelper((e.setParent(d, a), f.borderTop = d, e.setParent(u, a), f.borderBottom = u, s)),
          _step83;

      try {
        for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {
          var h = _step83.value;
          hr(e, r, n, t, o, i, h);
          var c = e.node(h),
              v = c.borderTop ? c.borderTop : h,
              l = c.borderBottom ? c.borderBottom : h,
              g = c.borderTop ? t : 2 * t,
              p = v !== l ? 1 : o - i[a] + 1;
          e.setEdge(d, v, {
            weight: g,
            minlen: p,
            nestingEdge: !0
          }), e.setEdge(l, u, {
            weight: g,
            minlen: p,
            nestingEdge: !0
          });
        }
      } catch (err) {
        _iterator83.e(err);
      } finally {
        _iterator83.f();
      }

      e.parent(a) || e.setEdge(r, d, {
        weight: 0,
        minlen: o + i[a]
      });
    } else a !== r && e.setEdge(r, a, {
      weight: 0,
      minlen: n
    });
  }

  function cr(e) {
    return "edge-proxy" == e.dummy;
  }

  function vr(e) {
    return "selfedge" == e.dummy;
  }

  var lr = 50,
      gr = 20,
      pr = 50,
      mr = "tb",
      wr = 1,
      _r = 1,
      br = 0,
      yr = 0,
      kr = 10,
      Er = "r";

  function Nr() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var r = {};

    for (var _i8 = 0, _Object$keys3 = Object.keys(e); _i8 < _Object$keys3.length; _i8++) {
      var n = _Object$keys3[_i8];
      r[n.toLowerCase()] = e[n];
    }

    return r;
  }

  function xr(e) {
    return e.nodes().map(function (r) {
      var n = e.node(r),
          t = e.parent(r),
          o = {
        v: r
      };
      return void 0 !== n && (o.value = n), void 0 !== t && (o.parent = t), o;
    });
  }

  function Ir(e) {
    return e.edges().map(function (r) {
      var n = e.edge(r),
          t = {
        v: r.v,
        w: r.w
      };
      return void 0 !== r.name && (t.name = r.name), void 0 !== n && (t.value = n), t;
    });
  }

  var Cr = Object.freeze({
    __proto__: null,
    write: function write(e) {
      var r = {
        options: {
          directed: e.isDirected(),
          multigraph: e.isMultigraph(),
          compound: e.isCompound()
        },
        nodes: xr(e),
        edges: Ir(e)
      };
      return void 0 !== e.graph() && (r.value = JSON.parse(JSON.stringify(e.graph()))), r;
    },
    read: function read(e) {
      var r = new x(e.options).setGraph(e.value);

      var _iterator84 = _createForOfIteratorHelper(e.nodes),
          _step84;

      try {
        for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {
          var n = _step84.value;
          r.setNode(n.v, n.value), n.parent && r.setParent(n.v, n.parent);
        }
      } catch (err) {
        _iterator84.e(err);
      } finally {
        _iterator84.f();
      }

      var _iterator85 = _createForOfIteratorHelper(e.edges),
          _step85;

      try {
        for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {
          var n = _step85.value;
          r.setEdge({
            v: n.v,
            w: n.w,
            name: n.name
          }, n.value);
        }
      } catch (err) {
        _iterator85.e(err);
      } finally {
        _iterator85.f();
      }

      return r;
    }
  }),
      Or = {
    Graph: x,
    GraphLike: I,
    alg: Le,
    json: Cr,
    PriorityQueue: be
  };
  e.Graph = x, e.GraphLike = I, e.PriorityQueue = be, e.acyclic = He, e.addBorderSegments = Ue, e.alg = Le, e.coordinateSystem = er, e.data = o, e.debug = ir, e.graphlib = Or, e.greedyFAS = Qe, e.json = Cr, e.layout = function (e, r) {
    var n = r && r.debugTiming ? Y : B;
    n("layout", function () {
      var r = n("  buildLayoutGraph", function () {
        return function (e) {
          var r,
              n,
              t,
              o,
              i,
              a,
              s,
              d,
              u,
              f,
              h,
              c,
              v,
              l,
              g,
              p = new x({
            multigraph: !0,
            compound: !0
          }),
              m = Nr(e.graph()),
              w = {
            nodesep: null !== (r = m.nodesep) && void 0 !== r ? r : pr,
            edgesep: null !== (n = m.edgesep) && void 0 !== n ? n : gr,
            ranksep: null !== (t = m.ranksep) && void 0 !== t ? t : lr,
            marginx: +(null !== (o = m.marginx) && void 0 !== o ? o : 0),
            marginy: +(null !== (i = m.marginy) && void 0 !== i ? i : 0),
            acyclicer: m.acyclicer,
            ranker: null !== (a = m.ranker) && void 0 !== a ? a : "network-simplex",
            rankdir: null !== (s = m.rankdir) && void 0 !== s ? s : mr,
            align: m.align
          };

          var _iterator86 = _createForOfIteratorHelper((p.setGraph(w), e.nodes())),
              _step86;

          try {
            for (_iterator86.s(); !(_step86 = _iterator86.n()).done;) {
              var _ = _step86.value;
              var b = Nr(e.node(_)),
                  y = {
                width: +(null !== (d = b && b.width) && void 0 !== d ? d : 0),
                height: +(null !== (u = b && b.height) && void 0 !== u ? u : 0)
              };
              p.setNode(_, y), p.setParent(_, e.parent(_));
            }
          } catch (err) {
            _iterator86.e(err);
          } finally {
            _iterator86.f();
          }

          var _iterator87 = _createForOfIteratorHelper(e.edges()),
              _step87;

          try {
            for (_iterator87.s(); !(_step87 = _iterator87.n()).done;) {
              var k = _step87.value;
              var E = Nr(e.edge(k)),
                  N = {
                minlen: null !== (f = E.minlen) && void 0 !== f ? f : wr,
                weight: null !== (h = E.weight) && void 0 !== h ? h : _r,
                width: null !== (c = E.width) && void 0 !== c ? c : br,
                height: null !== (v = E.height) && void 0 !== v ? v : yr,
                labeloffset: null !== (l = E.labeloffset) && void 0 !== l ? l : kr,
                labelpos: null !== (g = E.labelpos) && void 0 !== g ? g : Er
              };
              p.setEdge(k, N);
            }
          } catch (err) {
            _iterator87.e(err);
          } finally {
            _iterator87.f();
          }

          return p;
        }(e);
      });
      n("  runLayout", function () {
        !function (e, r) {
          r("    makeSpaceForEdgeLabels", function () {
            !function (e) {
              var r = e.graph();

              var _iterator88 = _createForOfIteratorHelper((r.ranksep /= 2, e.edges())),
                  _step88;

              try {
                for (_iterator88.s(); !(_step88 = _iterator88.n()).done;) {
                  var n = _step88.value;
                  var t = e.edge(n);
                  t.minlen *= 2, "c" !== t.labelpos.toLowerCase() && ("TB" === r.rankdir || "BT" === r.rankdir ? t.width += t.labeloffset : t.height += t.labeloffset);
                }
              } catch (err) {
                _iterator88.e(err);
              } finally {
                _iterator88.f();
              }
            }(e);
          }), r("    removeSelfEdges", function () {
            !function (e) {
              var _iterator89 = _createForOfIteratorHelper(e.edges()),
                  _step89;

              try {
                for (_iterator89.s(); !(_step89 = _iterator89.n()).done;) {
                  var r = _step89.value;

                  if (r.v === r.w) {
                    var n = e.node(r.v);
                    n.selfEdges || (n.selfEdges = []), n.selfEdges.push({
                      e: r,
                      label: e.edge(r)
                    }), e.removeEdge(r);
                  }
                }
              } catch (err) {
                _iterator89.e(err);
              } finally {
                _iterator89.f();
              }
            }(e);
          }), r("    acyclic", function () {
            He.run(e);
          }), r("    nestingGraph.run", function () {
            fr.run(e);
          }), r("    rank", function () {
            Be(S(e));
          }), r("    injectEdgeLabelProxies", function () {
            !function (e) {
              var _iterator90 = _createForOfIteratorHelper(e.edges()),
                  _step90;

              try {
                for (_iterator90.s(); !(_step90 = _iterator90.n()).done;) {
                  var r = _step90.value;
                  var n = e.edge(r);

                  if (n.width && n.height) {
                    var t = e.node(r.v),
                        o = e.node(r.w);
                    L(e, "edge-proxy", {
                      rank: (o.rank - t.rank) / 2 + t.rank,
                      e: r
                    }, "_ep");
                  }
                }
              } catch (err) {
                _iterator90.e(err);
              } finally {
                _iterator90.f();
              }
            }(e);
          }), r("    removeEmptyRanks", function () {
            D(e);
          }), r("    nestingGraph.cleanup", function () {
            fr.cleanup(e);
          }), r("    normalizeRanks", function () {
            F(e);
          }), r("    assignRankMinMax", function () {
            !function (e) {
              var r = 0;

              var _iterator91 = _createForOfIteratorHelper(e.nodes()),
                  _step91;

              try {
                for (_iterator91.s(); !(_step91 = _iterator91.n()).done;) {
                  var n = _step91.value;
                  var t = e.node(n);
                  t.borderTop && (t.minRank = e.node(t.borderTop).rank, t.maxRank = e.node(t.borderBottom).rank, r = Math.max(r, t.maxRank));
                }
              } catch (err) {
                _iterator91.e(err);
              } finally {
                _iterator91.f();
              }

              e.graph().maxRank = r;
            }(e);
          }), r("    removeEdgeLabelProxies", function () {
            !function (e) {
              var _iterator92 = _createForOfIteratorHelper(e.nodes()),
                  _step92;

              try {
                for (_iterator92.s(); !(_step92 = _iterator92.n()).done;) {
                  var r = _step92.value;
                  var n = e.node(r);
                  cr(n) && (e.edge(n.e).labelRank = n.rank, e.removeNode(r));
                }
              } catch (err) {
                _iterator92.e(err);
              } finally {
                _iterator92.f();
              }
            }(e);
          }), r("    normalize.run", function () {
            ar.run(e);
          }), r("    parentDummyChains", function () {
            dr(e);
          }), r("    addBorderSegments", function () {
            Ue(e);
          }), r("    order", function () {
            X(e);
          }), r("    insertSelfEdges", function () {
            !function (e) {
              var r,
                  n = R(e);

              var _iterator93 = _createForOfIteratorHelper(n),
                  _step93;

              try {
                for (_iterator93.s(); !(_step93 = _iterator93.n()).done;) {
                  var t = _step93.value;

                  for (var o = 0, i = 0; i < t.length; i++) {
                    var a = t[i],
                        s = e.node(a);

                    var _iterator94 = _createForOfIteratorHelper((s.order = i + o, null !== (r = s.selfEdges) && void 0 !== r ? r : [])),
                        _step94;

                    try {
                      for (_iterator94.s(); !(_step94 = _iterator94.n()).done;) {
                        var d = _step94.value;
                        L(e, "selfedge", {
                          width: d.label.width,
                          height: d.label.height,
                          rank: s.rank,
                          order: i + ++o,
                          e: d.e,
                          label: d.label
                        }, "_se");
                      }
                    } catch (err) {
                      _iterator94.e(err);
                    } finally {
                      _iterator94.f();
                    }

                    delete s.selfEdges;
                  }
                }
              } catch (err) {
                _iterator93.e(err);
              } finally {
                _iterator93.f();
              }
            }(e);
          }), r("    adjustCoordinateSystem", function () {
            er.adjust(e);
          }), r("    position", function () {
            ge(e);
          }), r("    positionSelfEdges", function () {
            !function (e) {
              var _iterator95 = _createForOfIteratorHelper(e.nodes()),
                  _step95;

              try {
                for (_iterator95.s(); !(_step95 = _iterator95.n()).done;) {
                  var r = _step95.value;
                  var n = e.node(r);

                  if (vr(n)) {
                    var t = e.node(n.e.v),
                        o = t.x + t.width / 2,
                        i = t.y,
                        a = n.x - o,
                        s = t.height / 2;
                    e.setEdge(n.e, n.label), e.removeNode(r), n.label.points = [{
                      x: o + 2 * a / 3,
                      y: i - s
                    }, {
                      x: o + 5 * a / 6,
                      y: i - s
                    }, {
                      x: o + a,
                      y: i
                    }, {
                      x: o + 5 * a / 6,
                      y: i + s
                    }, {
                      x: o + 2 * a / 3,
                      y: i + s
                    }], n.label.x = n.x, n.label.y = n.y;
                  }
                }
              } catch (err) {
                _iterator95.e(err);
              } finally {
                _iterator95.f();
              }
            }(e);
          }), r("    removeBorderNodes", function () {
            !function (e) {
              var _iterator96 = _createForOfIteratorHelper(e.nodes()),
                  _step96;

              try {
                for (_iterator96.s(); !(_step96 = _iterator96.n()).done;) {
                  var r = _step96.value;

                  if (e.children(r).length) {
                    var n = e.node(r),
                        t = e.node(n.borderTop),
                        o = e.node(n.borderBottom),
                        i = e.node(d(n.borderLeft)),
                        a = e.node(d(n.borderRight));
                    n.width = Math.abs(a.x - i.x), n.height = Math.abs(o.y - t.y), n.x = i.x + n.width / 2, n.y = t.y + n.height / 2;
                  }
                }
              } catch (err) {
                _iterator96.e(err);
              } finally {
                _iterator96.f();
              }

              var _iterator97 = _createForOfIteratorHelper(e.nodes()),
                  _step97;

              try {
                for (_iterator97.s(); !(_step97 = _iterator97.n()).done;) {
                  var r = _step97.value;
                  "border" === e.node(r).dummy && e.removeNode(r);
                }
              } catch (err) {
                _iterator97.e(err);
              } finally {
                _iterator97.f();
              }
            }(e);
          }), r("    normalize.undo", function () {
            ar.undo(e);
          }), r("    fixupEdgeLabelCoords", function () {
            !function (e) {
              var _iterator98 = _createForOfIteratorHelper(e.edges()),
                  _step98;

              try {
                for (_iterator98.s(); !(_step98 = _iterator98.n()).done;) {
                  var r = _step98.value;
                  var n = e.edge(r);
                  if (s(n, "x")) switch ("l" !== n.labelpos && "r" !== n.labelpos || (n.width -= n.labeloffset), n.labelpos) {
                    case "l":
                      n.x -= n.width / 2 + n.labeloffset;
                      break;

                    case "r":
                      n.x += n.width / 2 + n.labeloffset;
                  }
                }
              } catch (err) {
                _iterator98.e(err);
              } finally {
                _iterator98.f();
              }
            }(e);
          }), r("    undoCoordinateSystem", function () {
            er.undo(e);
          }), r("    translateGraph", function () {
            !function (e) {
              var r,
                  n,
                  t,
                  o = Number.POSITIVE_INFINITY,
                  i = 0,
                  a = Number.POSITIVE_INFINITY,
                  d = 0,
                  u = e.graph(),
                  f = null !== (r = u.marginx) && void 0 !== r ? r : 0,
                  h = null !== (n = u.marginy) && void 0 !== n ? n : 0;

              function c(e) {
                var r = e.x,
                    n = e.y,
                    t = e.width,
                    s = e.height;
                o = Math.min(o, r - t / 2), i = Math.max(i, r + t / 2), a = Math.min(a, n - s / 2), d = Math.max(d, n + s / 2);
              }

              var _iterator99 = _createForOfIteratorHelper(e.nodes()),
                  _step99;

              try {
                for (_iterator99.s(); !(_step99 = _iterator99.n()).done;) {
                  var v = _step99.value;
                  c(e.node(v));
                }
              } catch (err) {
                _iterator99.e(err);
              } finally {
                _iterator99.f();
              }

              var _iterator100 = _createForOfIteratorHelper(e.edges()),
                  _step100;

              try {
                for (_iterator100.s(); !(_step100 = _iterator100.n()).done;) {
                  var l = _step100.value;
                  s(p = e.edge(l), "x") && c(p);
                }
              } catch (err) {
                _iterator100.e(err);
              } finally {
                _iterator100.f();
              }

              var _iterator101 = _createForOfIteratorHelper((o -= f, a -= h, e.nodes())),
                  _step101;

              try {
                for (_iterator101.s(); !(_step101 = _iterator101.n()).done;) {
                  var v = _step101.value;
                  var g = e.node(v);
                  g.x -= o, g.y -= a;
                }
              } catch (err) {
                _iterator101.e(err);
              } finally {
                _iterator101.f();
              }

              var _iterator102 = _createForOfIteratorHelper(e.edges()),
                  _step102;

              try {
                for (_iterator102.s(); !(_step102 = _iterator102.n()).done;) {
                  var l = _step102.value;
                  var p = e.edge(l);

                  var _iterator103 = _createForOfIteratorHelper(null !== (t = p.points) && void 0 !== t ? t : []),
                      _step103;

                  try {
                    for (_iterator103.s(); !(_step103 = _iterator103.n()).done;) {
                      var m = _step103.value;
                      m.x -= o, m.y -= a;
                    }
                  } catch (err) {
                    _iterator103.e(err);
                  } finally {
                    _iterator103.f();
                  }

                  p.hasOwnProperty("x") && (p.x -= o), p.hasOwnProperty("y") && (p.y -= a);
                }
              } catch (err) {
                _iterator102.e(err);
              } finally {
                _iterator102.f();
              }

              u.width = i - o + f, u.height = d - a + h;
            }(e);
          }), r("    assignNodeIntersects", function () {
            !function (e) {
              var _iterator104 = _createForOfIteratorHelper(e.edges()),
                  _step104;

              try {
                for (_iterator104.s(); !(_step104 = _iterator104.n()).done;) {
                  var r = _step104.value;
                  var n,
                      t,
                      o = e.edge(r),
                      i = e.node(r.v),
                      a = e.node(r.w);
                  o.points ? (n = o.points[0], t = o.points[o.points.length - 1]) : (o.points = [], n = a, t = i), o.points.unshift(P(i, n)), o.points.push(P(a, t));
                }
              } catch (err) {
                _iterator104.e(err);
              } finally {
                _iterator104.f();
              }
            }(e);
          }), r("    reversePoints", function () {
            !function (e) {
              var _iterator105 = _createForOfIteratorHelper(e.edges()),
                  _step105;

              try {
                for (_iterator105.s(); !(_step105 = _iterator105.n()).done;) {
                  var r = _step105.value;
                  var n = e.edge(r);
                  n.reversed && n.points.reverse();
                }
              } catch (err) {
                _iterator105.e(err);
              } finally {
                _iterator105.f();
              }
            }(e);
          }), r("    acyclic.undo", function () {
            He.undo(e);
          });
        }(r, n);
      }), n("  updateInputGraph", function () {
        !function (e, r) {
          var _iterator106 = _createForOfIteratorHelper(e.nodes()),
              _step106;

          try {
            for (_iterator106.s(); !(_step106 = _iterator106.n()).done;) {
              var n = _step106.value;
              var t = e.node(n),
                  o = r.node(n);
              t && (t.x = o.x, t.y = o.y, r.children(n).length && (t.width = o.width, t.height = o.height));
            }
          } catch (err) {
            _iterator106.e(err);
          } finally {
            _iterator106.f();
          }

          var _iterator107 = _createForOfIteratorHelper(e.edges()),
              _step107;

          try {
            for (_iterator107.s(); !(_step107 = _iterator107.n()).done;) {
              var i = _step107.value;
              var a = e.edge(i),
                  d = r.edge(i);
              a.points = d.points, s(d, "x") && (a.x = d.x, a.y = d.y);
            }
          } catch (err) {
            _iterator107.e(err);
          } finally {
            _iterator107.f();
          }

          e.graph().width = r.graph().width, e.graph().height = r.graph().height;
        }(e, r);
      });
    });
  }, e.nestingGraph = fr, e.normalize = ar, e.order = ee, e.parentDummyChains = dr, e.position = pe, e.rank = $e, e.util = A, e.version = "0.1.3", Object.defineProperty(e, "__esModule", {
    value: !0
  });
});</script>
<script>"use strict";

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('graphre')) : typeof define === 'function' && define.amd ? define(['exports', 'graphre'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.nomnoml = {}, global.graphre));
})(void 0, function (exports, graphre) {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
   Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return _instanceof(value, P) ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  function range(_ref, count) {
    var _ref2 = _slicedToArray(_ref, 2),
        min = _ref2[0],
        max = _ref2[1];

    var output = [];

    for (var i = 0; i < count; i++) {
      output.push(min + (max - min) * i / (count - 1));
    }

    return output;
  }

  function sum(list, transform) {
    for (var i = 0, summation = 0, len = list.length; i < len; i++) {
      summation += transform(list[i]);
    }

    return summation;
  }

  function find(list, predicate) {
    for (var i = 0; i < list.length; i++) {
      if (predicate(list[i])) return list[i];
    }

    return undefined;
  }

  function last(list) {
    return list[list.length - 1];
  }

  function hasSubstring(haystack, needle) {
    if (needle === '') return true;
    if (!haystack) return false;
    return haystack.indexOf(needle) !== -1;
  }

  function merged(a, b) {
    function assign(target, data) {
      for (var key in data) {
        target[key] = data[key];
      }
    }

    var obj = {};
    assign(obj, a);
    assign(obj, b);
    return obj;
  }

  function indexBy(list, key) {
    var obj = {};

    for (var i = 0; i < list.length; i++) {
      obj[list[i][key]] = list[i];
    }

    return obj;
  }

  function uniqueBy(list, property) {
    var seen = {};
    var out = [];

    for (var i = 0; i < list.length; i++) {
      var key = list[i][property];

      if (!seen[key]) {
        seen[key] = true;
        out.push(list[i]);
      }
    }

    return out;
  }

  var util = /*#__PURE__*/Object.freeze({
    __proto__: null,
    range: range,
    sum: sum,
    find: find,
    last: last,
    hasSubstring: hasSubstring,
    merged: merged,
    indexBy: indexBy,
    uniqueBy: uniqueBy
  });

  function buildStyle(conf, title) {
    var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return {
      title: {
        bold: title.bold || false,
        underline: title.underline || false,
        italic: title.italic || false,
        center: title.center || false
      },
      body: {
        bold: body.bold || false,
        underline: body.underline || false,
        italic: body.italic || false,
        center: body.center || false
      },
      dashed: conf.dashed || false,
      fill: conf.fill || undefined,
      stroke: conf.stroke || undefined,
      visual: conf.visual || 'class',
      direction: conf.direction || undefined
    };
  }

  var styles = {
    ABSTRACT: buildStyle({
      visual: 'class'
    }, {
      center: true,
      italic: true
    }),
    ACTOR: buildStyle({
      visual: 'actor'
    }, {
      center: true
    }, {
      center: true
    }),
    CHOICE: buildStyle({
      visual: 'rhomb'
    }, {
      center: true
    }, {
      center: true
    }),
    CLASS: buildStyle({
      visual: 'class'
    }, {
      center: true,
      bold: true
    }),
    DATABASE: buildStyle({
      visual: 'database'
    }, {
      center: true,
      bold: true
    }, {
      center: true
    }),
    END: buildStyle({
      visual: 'end'
    }, {}),
    FRAME: buildStyle({
      visual: 'frame'
    }, {}),
    HIDDEN: buildStyle({
      visual: 'hidden'
    }, {}),
    INPUT: buildStyle({
      visual: 'input'
    }, {
      center: true
    }),
    INSTANCE: buildStyle({
      visual: 'class'
    }, {
      center: true,
      underline: true
    }),
    LABEL: buildStyle({
      visual: 'none'
    }, {
      center: true
    }),
    NOTE: buildStyle({
      visual: 'note'
    }, {}),
    PACKAGE: buildStyle({
      visual: 'package'
    }, {}),
    RECEIVER: buildStyle({
      visual: 'receiver'
    }, {}),
    REFERENCE: buildStyle({
      visual: 'class',
      dashed: true
    }, {
      center: true
    }),
    SENDER: buildStyle({
      visual: 'sender'
    }, {}),
    START: buildStyle({
      visual: 'start'
    }, {}),
    STATE: buildStyle({
      visual: 'roundrect'
    }, {
      center: true
    }),
    SYNC: buildStyle({
      visual: 'sync'
    }, {
      center: true
    }),
    TABLE: buildStyle({
      visual: 'table'
    }, {
      center: true,
      bold: true
    }),
    TRANSCEIVER: buildStyle({
      visual: 'transceiver'
    }, {}),
    USECASE: buildStyle({
      visual: 'ellipse'
    }, {
      center: true
    }, {
      center: true
    })
  };

  function box(config, clas) {
    clas.width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
      return e.width;
    })));
    clas.height = sum(clas.compartments, function (e) {
      return e.height;
    });
    clas.dividers = [];
    var y = 0;

    var _iterator = _createForOfIteratorHelper(clas.compartments),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var comp = _step.value;
        comp.x = 0;
        comp.y = y;
        comp.width = clas.width;
        y += comp.height;
        if (comp != last(clas.compartments)) clas.dividers.push([{
          x: 0,
          y: y
        }, {
          x: clas.width,
          y: y
        }]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  function icon(config, clas) {
    clas.dividers = [];
    clas.compartments = [];
    clas.width = config.fontSize * 2.5;
    clas.height = config.fontSize * 2.5;
  }

  var layouters = {
    actor: function actor(config, clas) {
      clas.width = Math.max.apply(Math, [config.padding * 2].concat(_toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      }))));
      clas.height = config.padding * 3 + sum(clas.compartments, function (e) {
        return e.height;
      });
      clas.dividers = [];
      var y = config.padding * 3;

      var _iterator2 = _createForOfIteratorHelper(clas.compartments),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var comp = _step2.value;
          comp.x = 0;
          comp.y = y;
          comp.width = clas.width;
          y += comp.height;
          if (comp != last(clas.compartments)) clas.dividers.push([{
            x: config.padding,
            y: y
          }, {
            x: clas.width - config.padding,
            y: y
          }]);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    class: box,
    database: function database(config, clas) {
      clas.width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      })));
      clas.height = sum(clas.compartments, function (e) {
        return e.height;
      }) + config.padding * 2;
      clas.dividers = [];
      var y = config.padding * 1.5;

      var _iterator3 = _createForOfIteratorHelper(clas.compartments),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var comp = _step3.value;
          comp.x = 0;
          comp.y = y;
          comp.width = clas.width;
          y += comp.height;

          if (comp != last(clas.compartments)) {
            var path = range([0, Math.PI], 16).map(function (a) {
              return {
                x: clas.width * 0.5 * (1 - Math.cos(a)),
                y: y + config.padding * (0.75 * Math.sin(a) - 0.5)
              };
            });
            clas.dividers.push(path);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    },
    ellipse: function ellipse(config, clas) {
      var width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      })));
      var height = sum(clas.compartments, function (e) {
        return e.height;
      });
      clas.width = width * 1.25;
      clas.height = height * 1.25;
      clas.dividers = [];
      var y = height * 0.125;

      var sq = function sq(x) {
        return x * x;
      };

      var rimPos = function rimPos(y) {
        return Math.sqrt(sq(0.5) - sq(y / clas.height - 0.5)) * clas.width;
      };

      var _iterator4 = _createForOfIteratorHelper(clas.compartments),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var comp = _step4.value;
          comp.x = width * 0.125;
          comp.y = y;
          comp.width = width;
          y += comp.height;
          if (comp != last(clas.compartments)) clas.dividers.push([{
            x: clas.width / 2 + rimPos(y) - 1,
            y: y
          }, {
            x: clas.width / 2 - rimPos(y) + 1,
            y: y
          }]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    },
    end: icon,
    frame: function frame(config, clas) {
      var w = clas.compartments[0].width;
      var h = clas.compartments[0].height;
      clas.compartments[0].width += h / 2;
      box(config, clas);
      if (clas.dividers.length) clas.dividers.shift();
      clas.dividers.unshift([{
        x: 0,
        y: h
      }, {
        x: w - h / 4,
        y: h
      }, {
        x: w + h / 4,
        y: h / 2
      }, {
        x: w + h / 4,
        y: 0
      }]);
    },
    hidden: function hidden(config, clas) {
      clas.dividers = [];
      clas.compartments = [];
      clas.width = 1;
      clas.height = 1;
    },
    input: box,
    none: box,
    note: box,
    package: box,
    receiver: box,
    rhomb: function rhomb(config, clas) {
      var width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      })));
      var height = sum(clas.compartments, function (e) {
        return e.height;
      });
      clas.width = width * 1.5;
      clas.height = height * 1.5;
      clas.dividers = [];
      var y = height * 0.25;

      var _iterator5 = _createForOfIteratorHelper(clas.compartments),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var comp = _step5.value;
          comp.x = width * 0.25;
          comp.y = y;
          comp.width = width;
          y += comp.height;
          var slope = clas.width / clas.height;
          if (comp != last(clas.compartments)) clas.dividers.push([{
            x: clas.width / 2 + (y < clas.height / 2 ? y * slope : (clas.height - y) * slope),
            y: y
          }, {
            x: clas.width / 2 - (y < clas.height / 2 ? y * slope : (clas.height - y) * slope),
            y: y
          }]);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    },
    roundrect: box,
    sender: box,
    start: icon,
    sync: function sync(config, clas) {
      clas.dividers = [];
      clas.compartments = [];

      if (config.direction == 'LR') {
        clas.width = config.lineWidth * 3;
        clas.height = config.fontSize * 5;
      } else {
        clas.width = config.fontSize * 5;
        clas.height = config.lineWidth * 3;
      }
    },
    table: function table(config, clas) {
      if (clas.compartments.length == 1) {
        box(config, clas);
        return;
      }

      var gridcells = clas.compartments.slice(1);
      var rows = [[]];

      function isRowBreak(e) {
        return !e.lines.length && !e.nodes.length && !e.relations.length;
      }

      function isRowFull(e) {
        var current = last(rows);
        return rows[0] != current && rows[0].length == current.length;
      }

      function isEnd(e) {
        return comp == last(gridcells);
      }

      var _iterator6 = _createForOfIteratorHelper(gridcells),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var comp = _step6.value;

          if (!isEnd() && isRowBreak(comp) && last(rows).length) {
            rows.push([]);
          } else if (isRowFull()) {
            rows.push([comp]);
          } else {
            last(rows).push(comp);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      var header = clas.compartments[0];
      var cellW = Math.max.apply(Math, [header.width / rows[0].length].concat(_toConsumableArray(gridcells.map(function (e) {
        return e.width;
      }))));
      var cellH = Math.max.apply(Math, _toConsumableArray(gridcells.map(function (e) {
        return e.height;
      })));
      clas.width = cellW * rows[0].length;
      clas.height = header.height + cellH * rows.length;
      var hh = header.height;
      clas.dividers = [[{
        x: 0,
        y: header.height
      }, {
        x: 0,
        y: header.height
      }]].concat(_toConsumableArray(rows.map(function (e, i) {
        return [{
          x: 0,
          y: hh + i * cellH
        }, {
          x: clas.width,
          y: hh + i * cellH
        }];
      })), _toConsumableArray(rows[0].map(function (e, i) {
        return [{
          x: (i + 1) * cellW,
          y: hh
        }, {
          x: (i + 1) * cellW,
          y: clas.height
        }];
      })));
      header.x = 0;
      header.y = 0;
      header.width = clas.width;

      for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
          var cell = rows[i][j];
          cell.x = j * cellW;
          cell.y = hh + i * cellH;
          cell.width = cellW;
        }
      }
    },
    transceiver: box
  };
  var visualizers = {
    actor: function actor(node, x, y, config, g) {
      var a = config.padding / 2;
      var yp = y + a * 4;
      var faceCenter = {
        x: node.x,
        y: yp - a
      };
      g.circle(faceCenter, a).fillAndStroke();
      g.path([{
        x: node.x,
        y: yp
      }, {
        x: node.x,
        y: yp + 2 * a
      }]).stroke();
      g.path([{
        x: node.x - a,
        y: yp + a
      }, {
        x: node.x + a,
        y: yp + a
      }]).stroke();
      g.path([{
        x: node.x - a,
        y: yp + a + config.padding
      }, {
        x: node.x,
        y: yp + config.padding
      }, {
        x: node.x + a,
        y: yp + a + config.padding
      }]).stroke();
    },
    class: function _class(node, x, y, config, g) {
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    database: function database(node, x, y, config, g) {
      var pad = config.padding;
      var cy = y - pad / 2;
      var pi = 3.1416;
      g.rect(x, y + pad, node.width, node.height - pad * 1.5).fill();
      g.path([{
        x: x,
        y: cy + pad * 1.5
      }, {
        x: x,
        y: cy - pad * 0.5 + node.height
      }]).stroke();
      g.path([{
        x: x + node.width,
        y: cy + pad * 1.5
      }, {
        x: x + node.width,
        y: cy - pad * 0.5 + node.height
      }]).stroke();
      g.ellipse({
        x: node.x,
        y: cy + pad * 1.5
      }, node.width, pad * 1.5).fillAndStroke();
      g.ellipse({
        x: node.x,
        y: cy - pad * 0.5 + node.height
      }, node.width, pad * 1.5, 0, pi).fillAndStroke();
    },
    ellipse: function ellipse(node, x, y, config, g) {
      g.ellipse({
        x: node.x,
        y: node.y
      }, node.width, node.height).fillAndStroke();
    },
    end: function end(node, x, y, config, g) {
      g.circle({
        x: node.x,
        y: y + node.height / 2
      }, node.height / 3).fillAndStroke();
      g.fillStyle(config.stroke);
      g.circle({
        x: node.x,
        y: y + node.height / 2
      }, node.height / 3 - config.padding / 2).fill();
    },
    frame: function frame(node, x, y, config, g) {
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    hidden: function hidden(node, x, y, config, g) {},
    input: function input(node, x, y, config, g) {
      g.circuit([{
        x: x + config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height
      }]).fillAndStroke();
    },
    none: function none(node, x, y, config, g) {},
    note: function note(node, x, y, config, g) {
      g.circuit([{
        x: x,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y + config.padding
      }, {
        x: x + node.width,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height
      }, {
        x: x,
        y: y
      }]).fillAndStroke();
      g.path([{
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y + config.padding
      }, {
        x: x + node.width,
        y: y + config.padding
      }]).stroke();
    },
    package: function _package(node, x, y, config, g) {
      var headHeight = node.compartments[0].height;
      g.rect(x, y + headHeight, node.width, node.height - headHeight).fillAndStroke();
      var w = g.measureText(node.name).width + 2 * config.padding;
      g.circuit([{
        x: x,
        y: y + headHeight
      }, {
        x: x,
        y: y
      }, {
        x: x + w,
        y: y
      }, {
        x: x + w,
        y: y + headHeight
      }]).fillAndStroke();
    },
    receiver: function receiver(node, x, y, config, g) {
      g.circuit([{
        x: x - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y
      }, {
        x: x + node.width,
        y: y + node.height
      }, {
        x: x - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height / 2
      }]).fillAndStroke();
    },
    rhomb: function rhomb(node, x, y, config, g) {
      g.circuit([{
        x: node.x,
        y: y
      }, {
        x: x + node.width,
        y: node.y
      }, {
        x: node.x,
        y: y + node.height
      }, {
        x: x,
        y: node.y
      }]).fillAndStroke();
    },
    roundrect: function roundrect(node, x, y, config, g) {
      var r = Math.min(config.padding * 2 * config.leading, node.height / 2);
      g.roundRect(x, y, node.width, node.height, r).fillAndStroke();
    },
    sender: function sender(node, x, y, config, g) {
      g.circuit([{
        x: x,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y + node.height / 2
      }, {
        x: x + node.width - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height
      }]).fillAndStroke();
    },
    start: function start(node, x, y, config, g) {
      g.fillStyle(config.stroke);
      g.circle({
        x: node.x,
        y: y + node.height / 2
      }, node.height / 2.5).fill();
    },
    sync: function sync(node, x, y, config, g) {
      g.fillStyle(config.stroke);
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    table: function table(node, x, y, config, g) {
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    transceiver: function transceiver(node, x, y, config, g) {
      g.circuit([{
        x: x - config.padding,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y + node.height / 2
      }, {
        x: x + node.width - config.padding,
        y: y + node.height
      }, {
        x: x - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height / 2
      }]).fillAndStroke();
    }
  };

  function layout(measurer, config, ast) {
    function measureLines(lines, fontWeight) {
      if (!lines.length) return {
        width: 0,
        height: config.padding
      };
      measurer.setFont(config, fontWeight, null);
      return {
        width: Math.round(Math.max.apply(Math, _toConsumableArray(lines.map(measurer.textWidth))) + 2 * config.padding),
        height: Math.round(measurer.textHeight() * lines.length + 2 * config.padding)
      };
    }

    function layoutCompartment(c, compartmentIndex, style) {
      var _a, _b;

      var textSize = measureLines(c.lines, compartmentIndex ? 'normal' : 'bold');

      if (!c.nodes.length && !c.relations.length) {
        c.width = textSize.width;
        c.height = textSize.height;
        c.offset = {
          x: config.padding,
          y: config.padding
        };
        return;
      }

      var styledConfig = Object.assign(Object.assign({}, config), {
        direction: (_a = style.direction) !== null && _a !== void 0 ? _a : config.direction
      });
      c.nodes.forEach(function (e) {
        return layoutClassifier(e, styledConfig);
      });
      var g = new graphre.graphlib.Graph();
      g.setGraph({
        rankdir: style.direction || config.direction,
        nodesep: config.spacing,
        edgesep: config.spacing,
        ranksep: config.spacing,
        acyclicer: config.acyclicer,
        ranker: config.ranker
      });

      var _iterator7 = _createForOfIteratorHelper(c.nodes),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var e = _step7.value;
          g.setNode(e.name, {
            width: e.layoutWidth,
            height: e.layoutHeight
          });
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      var _iterator8 = _createForOfIteratorHelper(c.relations),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var r = _step8.value;

          if (r.assoc.indexOf('_') > -1) {
            g.setEdge(r.start, r.end, {
              id: r.id,
              minlen: 0
            });
          } else if (((_b = config.gravity) !== null && _b !== void 0 ? _b : 1) != 1) {
            g.setEdge(r.start, r.end, {
              id: r.id,
              minlen: config.gravity
            });
          } else {
            g.setEdge(r.start, r.end, {
              id: r.id
            });
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      graphre.layout(g);
      var rels = indexBy(c.relations, 'id');
      var nodes = indexBy(c.nodes, 'name');
      g.nodes().forEach(function (name) {
        var node = g.node(name);
        nodes[name].x = node.x;
        nodes[name].y = node.y;
      });
      var left = 0;
      var right = 0;
      var top = 0;
      var bottom = 0;
      g.edges().forEach(function (edgeObj) {
        var edge = g.edge(edgeObj);
        var start = nodes[edgeObj.v];
        var end = nodes[edgeObj.w];
        var rel = rels[edge.id];
        rel.path = [start].concat(_toConsumableArray(edge.points), [end]).map(toPoint);
        var startP = rel.path[1];
        var endP = rel.path[rel.path.length - 2];
        layoutLabel(rel.startLabel, startP, adjustQuadrant(quadrant(startP, start, 4), start, end));
        layoutLabel(rel.endLabel, endP, adjustQuadrant(quadrant(endP, end, 2), end, start));
        left = Math.min.apply(Math, [left, rel.startLabel.x, rel.endLabel.x].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.x;
        })), _toConsumableArray(edge.points.map(function (e) {
          return e.x;
        }))));
        right = Math.max.apply(Math, [right, rel.startLabel.x + rel.startLabel.width, rel.endLabel.x + rel.endLabel.width].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.x;
        }))));
        top = Math.min.apply(Math, [top, rel.startLabel.y, rel.endLabel.y].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.y;
        }))));
        bottom = Math.max.apply(Math, [bottom, rel.startLabel.y + rel.startLabel.height, rel.endLabel.y + rel.endLabel.height].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.y;
        }))));
      });
      var graph = g.graph();
      var width = Math.max(graph.width, right - left);
      var height = Math.max(graph.height, bottom - top);
      var graphHeight = height ? height + 2 * config.gutter : 0;
      var graphWidth = width ? width + 2 * config.gutter : 0;
      c.width = Math.max(textSize.width, graphWidth) + 2 * config.padding;
      c.height = textSize.height + graphHeight + config.padding;
      c.offset = {
        x: config.padding - left,
        y: config.padding - top
      };
    }

    function toPoint(o) {
      return {
        x: o.x,
        y: o.y
      };
    }

    function layoutLabel(label, point, quadrant) {
      if (!label.text) {
        label.width = 0;
        label.height = 0;
        label.x = point.x;
        label.y = point.y;
      } else {
        var fontSize = config.fontSize;
        var lines = label.text.split('`');
        label.width = Math.max.apply(Math, _toConsumableArray(lines.map(function (l) {
          return measurer.textWidth(l);
        }))), label.height = fontSize * lines.length;
        label.x = point.x + (quadrant == 1 || quadrant == 4 ? config.padding : -label.width - config.padding), label.y = point.y + (quadrant == 3 || quadrant == 4 ? config.padding : -label.height - config.padding);
      }
    }

    function quadrant(point, node, fallback) {
      if (point.x < node.x && point.y < node.y) return 1;
      if (point.x > node.x && point.y < node.y) return 2;
      if (point.x > node.x && point.y > node.y) return 3;
      if (point.x < node.x && point.y > node.y) return 4;
      return fallback;
    }

    function adjustQuadrant(quadrant, point, opposite) {
      if (opposite.x == point.x || opposite.y == point.y) return quadrant;
      var flipHorizontally = [4, 3, 2, 1];
      var flipVertically = [2, 1, 4, 3];
      var oppositeQuadrant = opposite.y < point.y ? opposite.x < point.x ? 2 : 1 : opposite.x < point.x ? 3 : 4;

      if (oppositeQuadrant === quadrant) {
        if (config.direction === 'LR') return flipHorizontally[quadrant - 1];
        if (config.direction === 'TB') return flipVertically[quadrant - 1];
      }

      return quadrant;
    }

    function layoutClassifier(clas, config) {
      var style = config.styles[clas.type] || styles.CLASS;
      clas.compartments.forEach(function (co, i) {
        layoutCompartment(co, i, style);
      });
      layouters[style.visual](config, clas);
      clas.layoutWidth = clas.width + 2 * config.edgeMargin;
      clas.layoutHeight = clas.height + 2 * config.edgeMargin;
    }

    layoutCompartment(ast, 0, styles.CLASS);
    return ast;
  }

  var Compartment = function Compartment(lines, nodes, relations) {
    _classCallCheck(this, Compartment);

    this.lines = lines;
    this.nodes = nodes;
    this.relations = relations;
  };

  var Relation = function Relation() {
    _classCallCheck(this, Relation);
  };

  var Classifier = function Classifier(type, name, compartments) {
    _classCallCheck(this, Classifier);

    this.type = type;
    this.name = name;
    this.compartments = compartments;
    this.dividers = [];
  };
  /* parser generated by jison 0.4.18 */

  /*
    Returns a Parser object of the following structure:
     Parser: {
      yy: {}
    }
     Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),
       lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),
           options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },
           performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }
      token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */


  var nomnomlCoreParser = function () {
    var o = function o(k, v, _o, l) {
      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
        ;
      }

      return _o;
    },
        $V0 = [1, 5],
        $V1 = [1, 8],
        $V2 = [5, 6, 12, 14],
        $V3 = [12, 14],
        $V4 = [1, 22];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "root": 3,
        "compartment": 4,
        "EOF": 5,
        "SEP": 6,
        "slot": 7,
        "IDENT": 8,
        "class": 9,
        "association": 10,
        "parts": 11,
        "|": 12,
        "[": 13,
        "]": 14,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        5: "EOF",
        6: "SEP",
        8: "IDENT",
        12: "|",
        13: "[",
        14: "]"
      },
      productions_: [0, [3, 2], [3, 3], [3, 4], [3, 3], [7, 1], [7, 1], [7, 1], [4, 1], [4, 3], [11, 1], [11, 3], [11, 2], [10, 3], [9, 3]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
      /* action[1] */
      , $$
      /* vstack */
      , _$
      /* lstack */
      ) {
        /* this == yyval */
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
          case 2:
            return $$[$0 - 1];

          case 3:
          case 4:
            return $$[$0 - 2];

          case 5:
            this.$ = $$[$0].trim().replace(/\\(\[|\]|\|)/g, '$' + '1');
            break;

          case 6:
          case 7:
            this.$ = $$[$0];
            break;

          case 8:
          case 10:
            this.$ = [$$[$0]];
            break;

          case 9:
            this.$ = $$[$0 - 2].concat($$[$0]);
            break;

          case 11:
            this.$ = $$[$0 - 2].concat([$$[$0]]);
            break;

          case 12:
            this.$ = $$[$0 - 1].concat([[]]);
            break;

          case 13:
            var t = $$[$0 - 1].trim().replace(/\\(\[|\]|\|)/g, '$' + '1').match('^(.*?)([<:o+]*[-_]/?[-_]*[:o+>]*)(.*)$');

            if (!t) {
              throw new Error('line ' + _$[$0].first_line + ': Classifiers must be separated by a relation or a line break');
            }

            this.$ = {
              assoc: t[2],
              start: $$[$0 - 2],
              end: $$[$0],
              startLabel: t[1].trim(),
              endLabel: t[3].trim()
            };
            break;

          case 14:
            var type = 'CLASS';
            var id = $$[$0 - 1][0][0];
            var typeMatch = $$[$0 - 1][0][0].match('<([a-z]*)>(.*)');

            if (typeMatch) {
              type = typeMatch[1].toUpperCase();
              id = typeMatch[2].trim();
            }

            $$[$0 - 1][0][0] = id;
            this.$ = {
              type: type,
              id: id,
              parts: $$[$0 - 1]
            };
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        6: [1, 3],
        7: 4,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, {
        1: [3]
      }, {
        5: [1, 9],
        6: [1, 10]
      }, {
        4: 11,
        7: 4,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, o($V2, [2, 8]), o($V2, [2, 5]), o($V2, [2, 6], {
        8: [1, 12]
      }), o($V2, [2, 7]), {
        4: 14,
        7: 4,
        8: $V0,
        9: 6,
        10: 7,
        11: 13,
        13: $V1
      }, {
        1: [2, 1]
      }, {
        5: [1, 15],
        7: 16,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, {
        5: [1, 17],
        6: [1, 18]
      }, {
        9: 19,
        13: $V1
      }, {
        12: [1, 21],
        14: [1, 20]
      }, o($V3, [2, 10], {
        6: $V4
      }), {
        1: [2, 4]
      }, o($V2, [2, 9]), {
        1: [2, 2]
      }, {
        5: [1, 23],
        7: 16,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, o($V2, [2, 13]), o([5, 6, 8, 12, 14], [2, 14]), o($V3, [2, 12], {
        7: 4,
        9: 6,
        10: 7,
        4: 24,
        8: $V0,
        13: $V1
      }), {
        7: 16,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, {
        1: [2, 3]
      }, o($V3, [2, 11], {
        6: $V4
      })],
      defaultActions: {
        9: [2, 1],
        15: [2, 4],
        17: [2, 2],
        23: [2, 3]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        var lex = function lex() {
          var token;
          token = lexer.lex() || EOF;

          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }

          return token;
        };

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push('\'' + this.terminals_[p] + '\'');
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (_instanceof(action[0], Array) && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }
              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* generated by jison-lex 0.3.4 */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        // resets the lexer, sets new input
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        // consumes and returns one char from the input
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        // unshifts one char (or a string) into the input
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function more() {
          this._more = true;
          return this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        // retain first n characters of the match
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false; // rule action called reject() implying the next rule should be tested instead.
          }

          return false;
        },
        // return next match in input
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


            return false;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        // return next match that has a token
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              return 12;

            case 1:
              return 8;

            case 2:
              return 13;

            case 3:
              return 14;

            case 4:
              return 6;

            case 5:
              return 5;

            case 6:
              return 'INVALID';
          }
        },
        rules: [/^(?:\s*\|\s*)/, /^(?:(\\(\[|\]|\|)|[^\]\[|;\n])+)/, /^(?:\[)/, /^(?:\s*\])/, /^(?:[ ]*(;|\n)+[ ]*)/, /^(?:$)/, /^(?:.)/],
        conditions: {
          "INITIAL": {
            "rules": [0, 1, 2, 3, 4, 5, 6],
            "inclusive": true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  function parse(source) {
    function onlyCompilables(line) {
      var ok = line[0] !== '#' && line.trim().substring(0, 2) !== '//';
      return ok ? line.trim() : '';
    }

    function isDirective(line) {
      return line.text[0] === '#';
    }

    var lines = source.split('\n').map(function (s, i) {
      return {
        text: s,
        index: i
      };
    });
    var pureDirectives = lines.filter(isDirective);
    var directives = {};
    pureDirectives.forEach(function (line) {
      try {
        var tokens = line.text.substring(1).split(':');
        directives[tokens[0].trim()] = tokens[1].trim();
      } catch (e) {
        throw new Error('line ' + (line.index + 1) + ': Malformed directive');
      }
    });
    var pureDiagramCode = lines.map(function (e) {
      return onlyCompilables(e.text);
    }).join('\n');

    if (pureDiagramCode == '') {
      return {
        root: new Compartment([], [], []),
        config: getConfig(directives)
      };
    }

    var parseTree = intermediateParse(pureDiagramCode);
    return {
      root: transformParseIntoSyntaxTree(parseTree),
      config: getConfig(directives)
    };

    function directionToDagre(word) {
      if (word == 'down') return 'TB';
      if (word == 'right') return 'LR';else return 'TB';
    }

    function parseRanker(word) {
      if (word == 'network-simplex' || word == 'tight-tree' || word == 'longest-path') {
        return word;
      }

      return 'network-simplex';
    }

    function parseCustomStyle(styleDef) {
      var contains = hasSubstring;
      var floatingKeywords = styleDef.replace(/[a-z]*=[^ ]+/g, '');
      var titleDef = last(styleDef.match('title=([^ ]*)') || ['']);
      var bodyDef = last(styleDef.match('body=([^ ]*)') || ['']);
      return {
        title: {
          bold: contains(titleDef, 'bold') || contains(floatingKeywords, 'bold'),
          underline: contains(titleDef, 'underline') || contains(floatingKeywords, 'underline'),
          italic: contains(titleDef, 'italic') || contains(floatingKeywords, 'italic'),
          center: !(contains(titleDef, 'left') || contains(styleDef, 'align=left'))
        },
        body: {
          bold: contains(bodyDef, 'bold'),
          underline: contains(bodyDef, 'underline'),
          italic: contains(bodyDef, 'italic'),
          center: contains(bodyDef, 'center')
        },
        dashed: contains(styleDef, 'dashed'),
        fill: last(styleDef.match('fill=([^ ]*)') || []),
        stroke: last(styleDef.match('stroke=([^ ]*)') || []),
        visual: last(styleDef.match('visual=([^ ]*)') || []) || 'class',
        direction: directionToDagre(last(styleDef.match('direction=([^ ]*)') || []))
      };
    }

    function getConfig(d) {
      var _a;

      var userStyles = {};

      for (var key in d) {
        if (key[0] != '.') continue;
        var styleDef = d[key];
        userStyles[key.substring(1).toUpperCase()] = parseCustomStyle(styleDef);
      }

      return {
        arrowSize: +d.arrowSize || 1,
        bendSize: +d.bendSize || 0.3,
        direction: directionToDagre(d.direction),
        gutter: +d.gutter || 5,
        edgeMargin: +d.edgeMargin || 0,
        gravity: +((_a = d.gravity) !== null && _a !== void 0 ? _a : 1),
        edges: d.edges == 'hard' ? 'hard' : 'rounded',
        fill: (d.fill || '#eee8d5;#fdf6e3;#eee8d5;#fdf6e3').split(';'),
        background: d.background || 'transparent',
        fillArrows: d.fillArrows === 'true',
        font: d.font || 'Helvetica',
        fontSize: +d.fontSize || 12,
        leading: +d.leading || 1.25,
        lineWidth: +d.lineWidth || 3,
        padding: +d.padding || 8,
        spacing: +d.spacing || 40,
        stroke: d.stroke || '#33322E',
        title: d.title || '',
        zoom: +d.zoom || 1,
        acyclicer: d.acyclicer === 'greedy' ? 'greedy' : undefined,
        ranker: parseRanker(d.ranker),
        styles: merged(styles, userStyles)
      };
    }
  }

  function intermediateParse(source) {
    return nomnomlCoreParser.parse(source);
  }

  function transformParseIntoSyntaxTree(entity) {
    function isAstClassifier(obj) {
      return obj.parts !== undefined;
    }

    function isAstRelation(obj) {
      return obj.assoc !== undefined;
    }

    var relationId = 0;

    function transformCompartment(slots) {
      var lines = [];
      var rawClassifiers = [];
      var relations = [];
      slots.forEach(function (p) {
        if (typeof p === 'string') lines.push(p);

        if (isAstRelation(p)) {
          rawClassifiers.push(p.start);
          rawClassifiers.push(p.end);
          relations.push({
            id: relationId++,
            assoc: p.assoc,
            start: p.start.parts[0][0],
            end: p.end.parts[0][0],
            startLabel: {
              text: p.startLabel
            },
            endLabel: {
              text: p.endLabel
            }
          });
        }

        if (isAstClassifier(p)) {
          rawClassifiers.push(p);
        }
      });
      var allClassifiers = rawClassifiers.map(transformClassifier).sort(function (a, b) {
        return b.compartments.length - a.compartments.length;
      });
      var uniqClassifiers = uniqueBy(allClassifiers, 'name');
      var uniqRelations = relations.filter(function (a) {
        var _iterator9 = _createForOfIteratorHelper(relations),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var b = _step9.value;
            if (a === b) return true;
            if (b.start == a.start && b.end == a.end) return false;
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return true;
      });
      return new Compartment(lines, uniqClassifiers, uniqRelations);
    }

    function transformClassifier(entity) {
      var compartments = entity.parts.map(transformCompartment);
      return new Classifier(entity.type, entity.id, compartments);
    }

    return transformCompartment(entity);
  }

  function add(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y
    };
  }

  function diff(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }

  function mult(v, factor) {
    return {
      x: factor * v.x,
      y: factor * v.y
    };
  }

  function mag(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
  }

  function normalize(v) {
    return mult(v, 1 / mag(v));
  }

  function rot(a) {
    return {
      x: a.y,
      y: -a.x
    };
  }

  function render(graphics, config, compartment, setFont) {
    var g = graphics;

    function renderCompartment(compartment, color, style, level) {
      g.save();
      g.translate(compartment.offset.x, compartment.offset.y);
      g.fillStyle(color || config.stroke);
      compartment.lines.forEach(function (text, i) {
        g.textAlign(style.center ? 'center' : 'left');
        var x = style.center ? compartment.width / 2 - config.padding : 0;
        var y = (0.5 + (i + 0.5) * config.leading) * config.fontSize;

        if (text) {
          g.fillText(text, x, y);
        }

        if (style.underline) {
          var w = g.measureText(text).width;
          y += Math.round(config.fontSize * 0.2) + 0.5;

          if (style.center) {
            g.path([{
              x: x - w / 2,
              y: y
            }, {
              x: x + w / 2,
              y: y
            }]).stroke();
          } else {
            g.path([{
              x: x,
              y: y
            }, {
              x: x + w,
              y: y
            }]).stroke();
          }

          g.lineWidth(config.lineWidth);
        }
      });
      g.translate(config.gutter, config.gutter);
      compartment.relations.forEach(function (r) {
        renderRelation(r);
      });
      compartment.nodes.forEach(function (n) {
        renderNode(n, level);
      });
      g.restore();
    }

    function renderNode(node, level) {
      var x = Math.round(node.x - node.width / 2);
      var y = Math.round(node.y - node.height / 2);
      var style = config.styles[node.type] || styles.CLASS;
      g.fillStyle(style.fill || config.fill[level] || last(config.fill));
      g.strokeStyle(style.stroke || config.stroke);

      if (style.dashed) {
        var dash = Math.max(4, 2 * config.lineWidth);
        g.setLineDash([dash, dash]);
      }

      g.setData('name', node.name);
      var drawNode = visualizers[style.visual] || visualizers.class;
      drawNode(node, x, y, config, g);
      g.translate(x, y);

      var _iterator10 = _createForOfIteratorHelper(node.dividers),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var divider = _step10.value;
          g.path(divider).stroke();
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      g.translate(-x, -y);
      g.setLineDash([]);
      g.save();
      g.translate(x, y);
      node.compartments.forEach(function (part, i) {
        var textStyle = i == 0 ? style.title : style.body;
        g.save();
        g.translate(part.x, part.y);
        setFont(config, textStyle.bold ? 'bold' : 'normal', textStyle.italic ? 'italic' : null);
        renderCompartment(part, style.stroke, textStyle, level + 1);
        g.restore();
      });
      g.restore();
    }

    function strokePath(p) {
      if (config.edges === 'rounded') {
        var radius = config.spacing * config.bendSize;
        g.beginPath();
        g.moveTo(p[0].x, p[0].y);

        for (var i = 1; i < p.length - 1; i++) {
          g.arcTo(p[i].x, p[i].y, p[i + 1].x, p[i + 1].y, radius);
        }

        g.lineTo(last(p).x, last(p).y);
        g.stroke();
      } else g.path(p).stroke();
    }

    var empty = false,
        filled = true,
        diamond = true;

    function renderLabel(label) {
      if (!label || !label.text) return;
      var fontSize = config.fontSize;
      var lines = label.text.split('`');
      lines.forEach(function (l, i) {
        return g.fillText(l, label.x, label.y + fontSize * (i + 1));
      });
    }

    function renderRelation(r) {
      var start = r.path[1];
      var end = r.path[r.path.length - 2];
      var path = r.path.slice(1, -1);
      g.fillStyle(config.stroke);
      setFont(config, 'normal', null);
      renderLabel(r.startLabel);
      renderLabel(r.endLabel);

      if (r.assoc !== '-/-' && r.assoc !== '_/_') {
        if (hasSubstring(r.assoc, '--') || hasSubstring(r.assoc, '__')) {
          var dash = Math.max(4, 2 * config.lineWidth);
          g.setLineDash([dash, dash]);
          strokePath(path);
          g.setLineDash([]);
        } else strokePath(path);
      }

      function drawArrowEnd(id, path, end) {
        if (id === '>' || id === '<') drawArrow(path, filled, end, false);else if (id === ':>' || id === '<:') drawArrow(path, empty, end, false);else if (id === '+') drawArrow(path, filled, end, diamond);else if (id === 'o') drawArrow(path, empty, end, diamond);
      }

      var tokens = r.assoc.split(/[-_]/);
      drawArrowEnd(last(tokens), path, end);
      drawArrowEnd(tokens[0], path.reverse(), start);
    }

    function drawArrow(path, isOpen, arrowPoint, diamond) {
      var size = config.spacing * config.arrowSize / 30;
      var v = diff(path[path.length - 2], last(path));
      var nv = normalize(v);

      function getArrowBase(s) {
        return add(arrowPoint, mult(nv, s * size));
      }

      var arrowBase = getArrowBase(diamond ? 7 : 10);
      var t = rot(nv);
      var arrowButt = diamond ? getArrowBase(14) : isOpen && !config.fillArrows ? getArrowBase(5) : arrowBase;
      var arrow = [add(arrowBase, mult(t, 4 * size)), arrowButt, add(arrowBase, mult(t, -4 * size)), arrowPoint];
      g.fillStyle(isOpen ? config.stroke : config.fill[0]);
      g.circuit(arrow).fillAndStroke();
    }

    function snapToPixels() {
      if (config.lineWidth % 2 === 1) g.translate(0.5, 0.5);
    }

    function setBackground() {
      g.clear();
      g.save();
      g.strokeStyle('transparent');
      g.fillStyle(config.background);
      g.rect(0, 0, compartment.width, compartment.height).fill();
      g.restore();
    }

    g.save();
    g.scale(config.zoom, config.zoom);
    setBackground();
    setFont(config, 'bold', null);
    g.lineWidth(config.lineWidth);
    g.lineJoin('round');
    g.lineCap('round');
    g.strokeStyle(config.stroke);
    snapToPixels();
    renderCompartment(compartment, undefined, buildStyle({}, {}).title, 0);
    g.restore();
  }

  function GraphicsCanvas(canvas, callbacks) {
    var ctx = canvas.getContext('2d');
    var _mousePos = {
      x: 0,
      y: 0
    };
    var twopi = 2 * 3.1416;

    function mouseEventToPos(event) {
      var e = canvas;
      return {
        x: event.clientX - e.getBoundingClientRect().left - e.clientLeft + e.scrollLeft,
        y: event.clientY - e.getBoundingClientRect().top - e.clientTop + e.scrollTop
      };
    }

    if (callbacks) {
      canvas.addEventListener('mousedown', function (event) {
        if (callbacks.mousedown) callbacks.mousedown(mouseEventToPos(event));
      });
      canvas.addEventListener('mouseup', function (event) {
        if (callbacks.mouseup) callbacks.mouseup(mouseEventToPos(event));
      });
      canvas.addEventListener('mousemove', function (event) {
        _mousePos = mouseEventToPos(event);
        if (callbacks.mousemove) callbacks.mousemove(mouseEventToPos(event));
      });
    }

    var chainable = {
      stroke: function stroke() {
        ctx.stroke();
        return chainable;
      },
      fill: function fill() {
        ctx.fill();
        return chainable;
      },
      fillAndStroke: function fillAndStroke() {
        ctx.fill();
        ctx.stroke();
        return chainable;
      }
    };

    function tracePath(path, offset, s) {
      s = s === undefined ? 1 : s;
      offset = offset || {
        x: 0,
        y: 0
      };
      ctx.beginPath();
      ctx.moveTo(offset.x + s * path[0].x, offset.y + s * path[0].y);

      for (var i = 1, len = path.length; i < len; i++) {
        ctx.lineTo(offset.x + s * path[i].x, offset.y + s * path[i].y);
      }

      return chainable;
    }

    return {
      mousePos: function mousePos() {
        return _mousePos;
      },
      width: function width() {
        return canvas.width;
      },
      height: function height() {
        return canvas.height;
      },
      clear: function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      },
      circle: function circle(p, r) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, twopi);
        return chainable;
      },
      ellipse: function ellipse(center, rx, ry, start, stop) {
        if (start === undefined) start = 0;
        if (stop === undefined) stop = twopi;
        ctx.beginPath();
        ctx.save();
        ctx.translate(center.x, center.y);
        ctx.scale(1, ry / rx);
        ctx.arc(0, 0, rx / 2, start, stop);
        ctx.restore();
        return chainable;
      },
      arc: function arc(x, y, r, start, stop) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.arc(x, y, r, start, stop);
        return chainable;
      },
      roundRect: function roundRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + r, r);
        ctx.lineTo(x + w, y + h - r);
        ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
        ctx.lineTo(x + r, y + h);
        ctx.arcTo(x, y + h, x, y + h - r, r);
        ctx.lineTo(x, y + r);
        ctx.arcTo(x, y, x + r, y, r);
        ctx.closePath();
        return chainable;
      },
      rect: function rect(x, y, w, h) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + w, y);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x, y + h);
        ctx.closePath();
        return chainable;
      },
      path: tracePath,
      circuit: function circuit(path, offset, s) {
        tracePath(path, offset, s);
        ctx.closePath();
        return chainable;
      },
      setFont: function setFont(font, bold, ital, fontSize) {
        ctx.font = "".concat(bold, " ").concat(ital || '', " ").concat(fontSize, "pt ").concat(font, ", Helvetica, sans-serif");
      },
      fillStyle: function fillStyle(s) {
        ctx.fillStyle = s;
      },
      strokeStyle: function strokeStyle(s) {
        ctx.strokeStyle = s;
      },
      textAlign: function textAlign(a) {
        ctx.textAlign = a;
      },
      lineCap: function lineCap(cap) {
        ctx.lineCap = cap;
      },
      lineJoin: function lineJoin(join) {
        ctx.lineJoin = join;
      },
      lineWidth: function lineWidth(w) {
        ctx.lineWidth = w;
      },
      arcTo: function arcTo() {
        return ctx.arcTo.apply(ctx, arguments);
      },
      beginPath: function beginPath() {
        return ctx.beginPath.apply(ctx, arguments);
      },
      fillText: function fillText() {
        return ctx.fillText.apply(ctx, arguments);
      },
      lineTo: function lineTo() {
        return ctx.lineTo.apply(ctx, arguments);
      },
      measureText: function measureText() {
        return ctx.measureText.apply(ctx, arguments);
      },
      moveTo: function moveTo() {
        return ctx.moveTo.apply(ctx, arguments);
      },
      restore: function restore() {
        return ctx.restore.apply(ctx, arguments);
      },
      setData: function setData(name, value) {},
      save: function save() {
        return ctx.save.apply(ctx, arguments);
      },
      scale: function scale() {
        return ctx.scale.apply(ctx, arguments);
      },
      setLineDash: function setLineDash() {
        return ctx.setLineDash.apply(ctx, arguments);
      },
      stroke: function stroke() {
        return ctx.stroke.apply(ctx, arguments);
      },
      translate: function translate() {
        return ctx.translate.apply(ctx, arguments);
      }
    };
  }

  function xmlEncode(str) {
    return (str !== null && str !== void 0 ? str : '').toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
  }

  var charWidths = {
    "0": 10,
    "1": 10,
    "2": 10,
    "3": 10,
    "4": 10,
    "5": 10,
    "6": 10,
    "7": 10,
    "8": 10,
    "9": 10,
    " ": 5,
    "!": 5,
    "\"": 6,
    "#": 10,
    "$": 10,
    "%": 15,
    "&": 11,
    "'": 4,
    "(": 6,
    ")": 6,
    "*": 7,
    "+": 10,
    ",": 5,
    "-": 6,
    ".": 5,
    "/": 5,
    ":": 5,
    ";": 5,
    "<": 10,
    "=": 10,
    ">": 10,
    "?": 10,
    "@": 17,
    "A": 11,
    "B": 11,
    "C": 12,
    "D": 12,
    "E": 11,
    "F": 10,
    "G": 13,
    "H": 12,
    "I": 5,
    "J": 9,
    "K": 11,
    "L": 10,
    "M": 14,
    "N": 12,
    "O": 13,
    "P": 11,
    "Q": 13,
    "R": 12,
    "S": 11,
    "T": 10,
    "U": 12,
    "V": 11,
    "W": 16,
    "X": 11,
    "Y": 11,
    "Z": 10,
    "[": 5,
    "\\": 5,
    "]": 5,
    "^": 8,
    "_": 10,
    "`": 6,
    "a": 10,
    "b": 10,
    "c": 9,
    "d": 10,
    "e": 10,
    "f": 5,
    "g": 10,
    "h": 10,
    "i": 4,
    "j": 4,
    "k": 9,
    "l": 4,
    "m": 14,
    "n": 10,
    "o": 10,
    "p": 10,
    "q": 10,
    "r": 6,
    "s": 9,
    "t": 5,
    "u": 10,
    "v": 9,
    "w": 12,
    "x": 9,
    "y": 9,
    "z": 9,
    "{": 6,
    "|": 5,
    "}": 6,
    "~": 10
  };

  function GraphicsSvg(globalStyle, document) {
    var initialState = {
      x: 0,
      y: 0,
      stroke: 'none',
      strokeWidth: 1,
      dashArray: 'none',
      fill: 'none',
      textAlign: 'left',
      font: 'Helvetica, Arial, sans-serif',
      fontSize: 12,
      attributes: {}
    };
    var states = [initialState];
    var elements = [];
    var measurementCanvas = document ? document.createElement('canvas') : null;
    var ctx = measurementCanvas ? measurementCanvas.getContext('2d') : null;

    var Element = /*#__PURE__*/function () {
      function Element(name, attr, content) {
        _classCallCheck(this, Element);

        this.name = name;
        this.attr = attr;
        this.content = content || undefined;
      }

      _createClass(Element, [{
        key: "stroke",
        value: function stroke() {
          var base = this.attr.style || '';
          this.attr.style = base + 'stroke:' + lastDefined('stroke') + ';fill:none' + ';stroke-dasharray:' + lastDefined('dashArray') + ';stroke-width:' + lastDefined('strokeWidth') + ';';
          return this;
        }
      }, {
        key: "fill",
        value: function fill() {
          var base = this.attr.style || '';
          this.attr.style = base + 'stroke:none; fill:' + lastDefined('fill') + ';';
          return this;
        }
      }, {
        key: "fillAndStroke",
        value: function fillAndStroke() {
          var base = this.attr.style || '';
          this.attr.style = base + 'stroke:' + lastDefined('stroke') + ';fill:' + lastDefined('fill') + ';stroke-dasharray:' + lastDefined('dashArray') + ';stroke-width:' + lastDefined('strokeWidth') + ';';
          return this;
        }
      }]);

      return Element;
    }();

    function State(dx, dy) {
      return {
        x: dx,
        y: dy,
        stroke: null,
        strokeWidth: null,
        fill: null,
        textAlign: null,
        dashArray: 'none',
        font: null,
        fontSize: null,
        attributes: null
      };
    }

    function trans(coord, axis) {
      states.forEach(function (t) {
        coord += t[axis];
      });
      return coord;
    }

    function tX(coord) {
      return Math.round(10 * trans(coord, 'x')) / 10;
    }

    function tY(coord) {
      return Math.round(10 * trans(coord, 'y')) / 10;
    }

    function lastDefined(property) {
      for (var i = states.length - 1; i >= 0; i--) {
        if (states[i][property]) return states[i][property];
      }

      return undefined;
    }

    function last(list) {
      return list[list.length - 1];
    }

    function tracePath(path) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        x: 0,
        y: 0
      };
      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var d = path.map(function (e, i) {
        return (i ? 'L' : 'M') + tX(offset.x + s * e.x) + ' ' + tY(offset.y + s * e.y);
      }).join(' ');
      return newElement('path', {
        d: d
      });
    }

    function newElement(type, attr, content) {
      var element = new Element(type, attr, content);
      var extraData = lastDefined('attributes');

      for (var key in extraData) {
        element.attr['data-' + key] = extraData[key];
      }

      elements.push(element);
      return element;
    }

    return {
      width: function width() {
        return 0;
      },
      height: function height() {
        return 0;
      },
      clear: function clear() {},
      circle: function circle(p, r) {
        return newElement('circle', {
          r: r,
          cx: tX(p.x),
          cy: tY(p.y)
        });
      },
      ellipse: function ellipse(center, w, h, start, stop) {
        if (stop) {
          var y = tY(center.y);
          return newElement('path', {
            d: 'M' + tX(center.x - w / 2) + ' ' + y + 'A' + w / 2 + ' ' + h / 2 + ' 0 1 0 ' + tX(center.x + w / 2) + ' ' + y
          });
        } else {
          return newElement('ellipse', {
            cx: tX(center.x),
            cy: tY(center.y),
            rx: w / 2,
            ry: h / 2
          });
        }
      },
      arc: function arc(x, y, r) {
        return newElement('ellipse', {
          cx: tX(x),
          cy: tY(y),
          rx: r,
          ry: r
        });
      },
      roundRect: function roundRect(x, y, w, h, r) {
        return newElement('rect', {
          x: tX(x),
          y: tY(y),
          rx: r,
          ry: r,
          height: h,
          width: w
        });
      },
      rect: function rect(x, y, w, h) {
        return newElement('rect', {
          x: tX(x),
          y: tY(y),
          height: h,
          width: w
        });
      },
      path: tracePath,
      circuit: function circuit(path, offset, s) {
        var element = tracePath(path, offset, s);
        element.attr.d += ' Z';
        return element;
      },
      setFont: function setFont(font, bold, ital, fontSize) {
        var font = "".concat(bold, " ").concat(ital || '', " ").concat(fontSize, "pt ").concat(font, ", Helvetica, sans-serif");
        last(states).font = font;
        last(states).fontSize = fontSize;
      },
      strokeStyle: function strokeStyle(stroke) {
        last(states).stroke = stroke;
      },
      fillStyle: function fillStyle(fill) {
        last(states).fill = fill;
      },
      arcTo: function arcTo(x1, y1, x2, y2) {
        last(elements).attr.d += 'L' + tX(x1) + ' ' + tY(y1) + ' L' + tX(x2) + ' ' + tY(y2) + ' ';
      },
      beginPath: function beginPath() {
        return newElement('path', {
          d: ''
        });
      },
      fillText: function fillText(text, x, y) {
        var attr = {
          x: tX(x),
          y: tY(y),
          style: 'fill: ' + last(states).fill + ';'
        };
        var font = lastDefined('font');

        if (font) {
          attr.style += 'font:' + font + ';';
        }

        if (lastDefined('textAlign') === 'center') {
          attr.style += 'text-anchor: middle;';
        }

        return newElement('text', attr, text);
      },
      lineCap: function lineCap(cap) {
        globalStyle += ';stroke-linecap:' + cap;
      },
      lineJoin: function lineJoin(join) {
        globalStyle += ';stroke-linejoin:' + join;
      },
      lineTo: function lineTo(x, y) {
        last(elements).attr.d += 'L' + tX(x) + ' ' + tY(y) + ' ';
        return last(elements);
      },
      lineWidth: function lineWidth(w) {
        last(states).strokeWidth = w;
      },
      measureText: function measureText(s) {
        if (ctx) {
          ctx.font = lastDefined('font') || 'normal 12pt Helvetica';
          return ctx.measureText(s);
        } else {
          return {
            width: sum(s, function (c) {
              var scale = lastDefined('fontSize') / 12;

              if (charWidths[c]) {
                return charWidths[c] * scale;
              }

              return 16 * scale;
            })
          };
        }
      },
      moveTo: function moveTo(x, y) {
        last(elements).attr.d += 'M' + tX(x) + ' ' + tY(y) + ' ';
      },
      restore: function restore() {
        states.pop();
      },
      save: function save() {
        states.push(State(0, 0));
      },
      setData: function setData(name, value) {
        lastDefined('attributes')[name] = value;
      },
      scale: function scale() {},
      setLineDash: function setLineDash(d) {
        last(states).dashArray = d.length === 0 ? 'none' : d[0] + ' ' + d[1];
      },
      stroke: function stroke() {
        last(elements).stroke();
      },
      textAlign: function textAlign(a) {
        last(states).textAlign = a;
      },
      translate: function translate(dx, dy) {
        last(states).x += dx;
        last(states).y += dy;
      },
      serialize: function serialize(size, desc, title) {
        function toAttr(obj) {
          return Object.keys(obj).map(function (key) {
            return "".concat(key, "=\"").concat(xmlEncode(obj[key]), "\"");
          }).join(' ');
        }

        function toHtml(e) {
          return "<".concat(e.name, " ").concat(toAttr(e.attr), ">").concat(xmlEncode(e.content), "</").concat(e.name, ">");
        }

        var elementsToSerialize = elements;

        if (desc) {
          elementsToSerialize.unshift(new Element('desc', {}, desc));
        }

        if (title) {
          elementsToSerialize.unshift(new Element('title', {}, title));
        }

        var innerSvg = elementsToSerialize.map(toHtml).join('\n  ');
        var attrs = {
          version: '1.1',
          baseProfile: 'full',
          width: size.width,
          height: size.height,
          viewbox: '0 0 ' + size.width + ' ' + size.height,
          xmlns: 'http://www.w3.org/2000/svg',
          'xmlns:xlink': 'http://www.w3.org/1999/xlink',
          'xmlns:ev': 'http://www.w3.org/2001/xml-events',
          style: 'font:' + lastDefined('font') + ';' + globalStyle
        };
        return '<svg ' + toAttr(attrs) + '>\n  ' + innerSvg + '\n</svg>';
      }
    };
  }

  function fitCanvasSize(canvas, rect, zoom) {
    canvas.width = rect.width * zoom;
    canvas.height = rect.height * zoom;
  }

  function createMeasurer(config, graphics) {
    return {
      setFont: function setFont(conf, bold, ital) {
        graphics.setFont(conf.font, bold, ital !== null && ital !== void 0 ? ital : null, config.fontSize);
      },
      textWidth: function textWidth(s) {
        return graphics.measureText(s).width;
      },
      textHeight: function textHeight() {
        return config.leading * config.fontSize;
      }
    };
  }

  function parseAndRender(code, graphics, canvas, scale) {
    var parsedDiagram = parse(code);
    var config = parsedDiagram.config;
    var measurer = createMeasurer(config, graphics);
    var graphLayout = layout(measurer, config, parsedDiagram.root);

    if (canvas) {
      fitCanvasSize(canvas, graphLayout, config.zoom * scale);
    }

    config.zoom *= scale;
    render(graphics, config, graphLayout, measurer.setFont);
    return {
      config: config,
      layout: graphLayout
    };
  }

  function draw(canvas, code, scale) {
    return parseAndRender(code, GraphicsCanvas(canvas), canvas, scale || 1);
  }

  function renderSvg(code, document) {
    var skCanvas = GraphicsSvg('', document);

    var _parseAndRender = parseAndRender(code, skCanvas, null, 1),
        config = _parseAndRender.config,
        layout = _parseAndRender.layout;

    return skCanvas.serialize({
      width: layout.width,
      height: layout.height
    }, code, config.title);
  }

  var ImportDepthError = /*#__PURE__*/function (_Error) {
    _inherits(ImportDepthError, _Error);

    var _super = _createSuper(ImportDepthError);

    function ImportDepthError() {
      _classCallCheck(this, ImportDepthError);

      return _super.call(this, 'max_import_depth exceeded');
    }

    return ImportDepthError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function processAsyncImports(source, loadFile) {
    var maxImportDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var lenientLoadFile, imports, imported, _i2, _imports, imp;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              lenientLoadFile = function _lenientLoadFile(key) {
                return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return loadFile(key);

                        case 3:
                          _context.t0 = _context.sent;

                          if (_context.t0) {
                            _context.next = 6;
                            break;
                          }

                          _context.t0 = '';

                        case 6:
                          return _context.abrupt("return", _context.t0);

                        case 9:
                          _context.prev = 9;
                          _context.t1 = _context["catch"](0);
                          return _context.abrupt("return", '');

                        case 12:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 9]]);
                }));
              };

              if (!(maxImportDepth == -1)) {
                _context2.next = 3;
                break;
              }

              throw new ImportDepthError();

            case 3:
              imports = [];
              source.replace(/#import: *(.*)/g, function (a, file) {
                var promise = lenientLoadFile(file).then(function (contents) {
                  return processAsyncImports(contents, loadFile, maxImportDepth - 1);
                });
                imports.push({
                  file: file,
                  promise: promise
                });
                return '';
              });
              imported = {};
              _i2 = 0, _imports = imports;

            case 7:
              if (!(_i2 < _imports.length)) {
                _context2.next = 15;
                break;
              }

              imp = _imports[_i2];
              _context2.next = 11;
              return imp.promise;

            case 11:
              imported[imp.file] = _context2.sent;

            case 12:
              _i2++;
              _context2.next = 7;
              break;

            case 15:
              return _context2.abrupt("return", source.replace(/#import: *(.*)/g, function (a, file) {
                return imported[file];
              }));

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  }

  function processImports(source, loadFile) {
    var maxImportDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;

    if (maxImportDepth == -1) {
      throw new ImportDepthError();
    }

    function lenientLoadFile(key) {
      try {
        return loadFile(key) || '';
      } catch (e) {
        return '';
      }
    }

    return source.replace(/#import: *(.*)/g, function (a, file) {
      return processImports(lenientLoadFile(file), loadFile, maxImportDepth - 1);
    });
  }

  function compileFile(filepath, maxImportDepth) {
    var fs = require('fs');

    var path = require('path');

    var directory = path.dirname(filepath);
    var rootFileName = filepath.substr(directory.length);

    function loadFile(filename) {
      return fs.readFileSync(path.join(directory, filename), {
        encoding: 'utf8'
      });
    }

    return processImports(loadFile(rootFileName), loadFile, maxImportDepth);
  }

  var version = '1.3.1';
  exports.Classifier = Classifier;
  exports.Compartment = Compartment;
  exports.ImportDepthError = ImportDepthError;
  exports.Relation = Relation;
  exports.compileFile = compileFile;
  exports.draw = draw;
  exports.intermediateParse = intermediateParse;
  exports.layout = layout;
  exports.parse = parse;
  exports.processAsyncImports = processAsyncImports;
  exports.processImports = processImports;
  exports.renderSvg = renderSvg;
  exports.skanaar = util;
  exports.styles = styles;
  exports.transformParseIntoSyntaxTree = transformParseIntoSyntaxTree;
  exports.version = version;
  exports.visualizers = visualizers;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});</script>
<script>HTMLWidgets.widget({
  name: 'nomnoml',
  type: 'output',

  factory: function(el, width, height) {
    var g = null;
    var svg = null;
    var png = null;
    var canvas = null;
    var wrapper = null;
    var code = null;
    var initialized_canvas = false;
    var initialized_svg = false;
    
    var resizeSvg = function(width, height) {
      el.style.width = width;
      el.style.height = height;
      
      wrapper.setAttribute('width', width);
      wrapper.setAttribute('height', height);
      
      var scale = Math.min(width / svg.getAttribute("width"), height / svg.getAttribute("height"));
      var innerWidth = svg.getAttribute("width") * scale;
      var innerHeight = svg.getAttribute("height") * scale;
      g.setAttribute(
        "transform",
        "translate(" + (width  / 2 - innerWidth / 2) +
        "," + (height / 2 - innerHeight / 2) + ")" +
        "scale(" + scale + ") "
      );  
    };
    
    var resizeCanvas = function(width, height) {
      
      nomnoml.draw(canvas, code);
      
      var actualWidth = canvas.getAttribute('width');
      var actualHeight = canvas.getAttribute('height');
      
      var scale = Math.min(width / actualWidth, height / actualHeight);
      
      canvas.style = "transform:" +
        "translate(" + (-actualWidth / 2) + "px," + (-actualHeight / 2) + "px) " +
        "scale(" + scale + ") " +
        "translate(" + (width / 2 / scale) + "px," + (height / 2 / scale) + "px); " +
        "position: absolute; ";
    };
    
    return {
      renderValue: function(x) {
        code = x.code;
        png  = x.png;
        
        if (x.svg) {
          if (!initialized_svg) {
            
            wrapper = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            wrapper.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
            el.appendChild(wrapper);
            if (x.className) el.classList.add(x.className);
            
            g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
            wrapper.appendChild(g);
            
            initialized_svg = true;
          }
          
          g.innerHTML = nomnoml.renderSvg(x.code);
          
          svg = g.childNodes[0];
          resizeSvg(width, height);
        }
        else {
          if (!initialized_canvas) {
            
            /* Create a new canvas only on first initalization */
            el.style.textAlign = "left";
            canvas = document.createElement("canvas");
            el.appendChild(canvas);
            initialized_canvas = true;
          }
          
          resizeCanvas(width, height);
          if (png !== null) {
            canvas = document.getElementsByTagName("canvas")[0];
            canvas.toDataURL("image/png");
          }
        }
      },

      resize: function(width, height) {
        if (canvas)
          resizeCanvas(width, height);
        else
          resizeSvg(width, height);
      },
      
      p: "hello world"
    };
  }
});</script>

</head>
<body style="background-color: white;">
<div id="htmlwidget_container">
  <div class="nomnoml html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-a22dfcc7f73caba96613" style="width:960px;height:500px;"></div>
</div>
<script type="application/json" data-for="htmlwidget-a22dfcc7f73caba96613">{"x":{"code":"# direction: right\n#.expfun: visual=roundrect fill=#ddebf7 title=bold\n#.unexpfun: visual=roundrect fill=#fff2cc title=bold\n#.trimmed: visual=roundrect fill=#fce4d6 dashed title=bold\n#.expdata: visual=database fill=#e2efda title=bold\n#.unexpdata: visual=database fill=#fff2cc title=bold\n#.callroutine: visual=transceiver fill=#ededed\n[<expfun> run_app (4)]\n[<expfun> run_app (4)] -> [<unexpfun> app_server (25)]\n[<unexpfun> app_server (25)] -> [<unexpfun> mod_poke_evolve_server (26)]\n[<unexpfun> app_server (25)] -> [<unexpfun> mod_poke_info_server (23)]\n[<unexpfun> app_server (25)] -> [<unexpfun> mod_poke_location_server (20)]\n[<unexpfun> app_server (25)] -> [<unexpfun> mod_poke_move_server (19)]\n[<unexpfun> app_server (25)] -> [<unexpfun> mod_poke_select_server (7)]\n[<unexpfun> app_server (25)] -> [<unexpfun> mod_poke_stats_server (27)]\n[<unexpfun> app_server (25)] -> [<unexpfun> mod_poke_type_server (43)]","svg":true},"evals":[],"jsHooks":[]}</script>
<script type="application/htmlwidget-sizing" data-for="htmlwidget-a22dfcc7f73caba96613">{"viewer":{"width":450,"height":350,"padding":15,"fill":true},"browser":{"width":960,"height":500,"padding":40,"fill":false}}</script>
</body>
</html>
